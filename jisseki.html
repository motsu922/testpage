<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>QR Log Dashboard</title>
<style>
:root{
  --bg:#ffffff;
  --fg:#111827;
  --muted:#6b7280;
  --border:#e5e7eb;
  --card:#ffffff;
  --accent:#2563eb;
  --accent-weak:#eff6ff;
  --danger:#ef4444;
  --success:#16a34a;
  --warn:#f59e0b;
}
*{ box-sizing:border-box; }
html,body{ height:100%; }
body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"; background:var(--bg); color:var(--fg); margin:0; line-height:1.5; }
.container{ max-width:1400px; margin:0 auto; padding:16px; }
h1{ font-size:20px; margin:0 0 12px; }
.controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
select, input[type="date"], input[type="datetime-local"], input[type="text"]{
  padding:8px 10px; border:1px solid var(--border); border-radius:8px; background:#fff; color:var(--fg);
}
button{ padding:8px 12px; border:1px solid var(--border); border-radius:8px; background:#fff; cursor:pointer; }
button.primary{ background:var(--accent); color:#fff; border-color:var(--accent); }
.small{ color:var(--muted); font-size:12px; }
.grid{ display:grid; grid-template-columns:repeat(12, 1fr); gap:12px; }
.card{ background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; }
.card h2{ font-size:16px; margin:0 0 8px; }
.flex{ display:flex; gap:8px; align-items:center; }
.divider{ height:1px; background:var(--border); margin:8px 0; }

.line-cards{ display:grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap:12px; }
.line-card{ border:1px solid var(--border); border-radius:12px; padding:10px; background:#fff; display:flex; flex-direction:column; gap:8px; }
.line-card-header{ font-weight:700; }
.product-item{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
.product-name{ font-weight:600; }
.product-qty{ color:var(--muted); }
.line-card-footer{ display:flex; justify-content:space-between; align-items:center; gap:8px; font-size:12px; color:var(--muted); }
.highlight-stop{ color:var(--danger); font-weight:600; }

.table{ width:100%; border-collapse:collapse; }
.table th, .table td{ border-top:1px solid var(--border); padding:8px; text-align:left; font-size:13px; }
.table th{ background:#f9fafb; font-weight:600; }
.table tfoot td{ font-weight:700; }

/* 時間帯バッジ（最小追加） */
.time-badges{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
.time-badge{ font-size:12px; padding:2px 8px; border:1px solid var(--border); border-radius:999px; background:#f9fafb; color:var(--muted); }
</style>
</head>
<body>
  <div class="container">
    <h1>QR Log Dashboard</h1>

    <div class="card">
      <div class="controls">
        <label class="small">期間:</label>
        <input type="date" id="fromDate">
        <span class="small">〜</span>
        <input type="date" id="toDate">

        <label class="small">ライン:</label>
        <select id="lineFilter" multiple size="1" style="min-width:140px;"></select>

        <label class="small">品番:</label>
        <input type="text" id="productFilter" placeholder="部分一致でフィルタ">

        <label class="small">時間帯集計:</label>
        <select id="hourGroup">
          <option value="1">1時間</option>
          <option value="2">2時間</option>
          <option value="4" selected>4時間</option>
          <option value="8">8時間</option>
        </select>

        <button id="refreshBtn" class="primary">再計算</button>
        <span class="small" id="recordsInfo"></span>
      </div>
      <div class="divider"></div>
      <div class="small">メモ: フィルタはサマリー、グラフ、表すべてに反映されます。</div>
    </div>

    <div class="grid" style="margin-top:12px;">
      <div class="card" style="grid-column: span 12;">
        <h2>ライン別サマリー（製品ごとの時間帯バッジ付き）</h2>
        <div id="lineSummaryCards" class="line-cards"></div>
      </div>

      <div class="card" style="grid-column: span 12;">
        <h2>時間推移（件数）</h2>
        <canvas id="timeSeriesChart" height="120"></canvas>
      </div>

      <div class="card" style="grid-column: span 6;">
        <h2>停止時間（ライン別 合計分）</h2>
        <canvas id="stopTimeChart" height="200"></canvas>
      </div>

      <div class="card" style="grid-column: span 6;">
        <h2>停止内訳（イベント一覧）</h2>
        <table class="table" id="stopDetailTable">
          <thead>
            <tr>
              <th>ライン</th>
              <th>開始</th>
              <th>終了</th>
              <th>停止分</th>
              <th>理由</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr><td colspan="5">合計: <span id="stopTotal"></span> 分</td></tr>
          </tfoot>
        </table>
      </div>

      <div class="card" style="grid-column: span 12;">
        <h2>時間帯別 件数テーブル</h2>
        <table class="table" id="hourlyTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script type="module">
// ======== ダミーデータ/ロード部（あなたの実データ読み込みに置き換えて運用中） ========
// ここでは既にあなたの環境で使っている前提の構造を維持しています。
// r = { line, sliced(=品番切り出し), ts(=ローカル時刻文字列 or ISO), readAt(=Firebase Timestamp相当), ... }

const hourGroup = document.getElementById('hourGroup');
const fromDate = document.getElementById('fromDate');
const toDate = document.getElementById('toDate');
const lineFilter = document.getElementById('lineFilter');
const productFilter = document.getElementById('productFilter');
const refreshBtn = document.getElementById('refreshBtn');
const recordsInfo = document.getElementById('recordsInfo');

let allData = [];   // 全件（既存の取込処理がここに流し込む想定）
let chart1 = null;
let chart2 = null;

// 例: 実運用ではここをFirestore/CSVなりで埋めています
init();

async function init(){
  // 日付初期値
  const today = new Date();
  const start = new Date(today.getFullYear(), today.getMonth(), today.getDate()-7);
  fromDate.value = toDateStr(start);
  toDate.value = toDateStr(today);

  // ダミーデータ（実運用時はここ不要）
  allData = generateMock();

  // ライン選択肢
  const lines = Array.from(new Set(allData.map(r=>r.line||"不明"))).sort();
  lineFilter.innerHTML = lines.map(l=>`<option value="${escapeHTML(l)}">${escapeHTML(l)}</option>`).join('');
  // 既定で全選択扱いに
  lineFilter.size = Math.min(lines.length || 1, 6);

  updateDashboard();
}

function toDateStr(d){
  const z = n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;
}
function parseClientDate(v){
  // 既存仕様: tsが "YYYY-MM-DD HH:mm:ss" または ISO の想定
  if(!v) return null;
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}
function getQuantity(sliced){
  // 既存仕様: 「切出し値＝生産した品番」「1レコード=1個」などの前提がある場合はここで調整
  // ここでは 1 件 = 1 個 としてカウント（元仕様を尊重）
  return 1;
}
function escapeHTML(s){
  return (s==null?"":String(s)).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

function getFilteredData(){
  const from = fromDate.value ? new Date(fromDate.value+"T00:00:00") : null;
  const to = toDate.value ? new Date(toDate.value+"T23:59:59") : null;

  const selectedLines = Array.from(lineFilter.selectedOptions || []).map(o=>o.value);
  const selectedSet = new Set(selectedLines);
  const productKeyword = (productFilter.value||"").trim();

  let rows = allData.filter(r=>{
    // 日付フィルタ
    let dt = null;
    if (r.ts) dt = parseClientDate(r.ts);
    if (!dt && r.readAt && r.readAt.seconds) dt = new Date(r.readAt.seconds*1000);
    if (!dt) return false;
    if (from && dt < from) return false;
    if (to && dt > to) return false;

    // ライン
    const line = r.line || "不明";
    if (selectedSet.size>0 && !selectedSet.has(line)) return false;

    // 品番キーワード（部分一致）
    if (productKeyword){
      const p = (r.sliced || "");
      if (!p.includes(productKeyword)) return false;
    }
    return true;
  });

  recordsInfo.textContent = `表示件数: ${rows.length.toLocaleString()} 件`;
  return rows;
}

// ======== ★追加: 時間帯バンド関数 ========
// 指定のグループ時間(1/2/4/8h)で、時刻を「HH:MM–HH:MM」帯に丸める
function makeHourBand(date, groupHours){
  const h = date.getHours();
  const startH = Math.floor(h / groupHours) * groupHours;
  const endH = (startH + groupHours) % 24;
  const hh = n => String(n).padStart(2, "0");
  return `${hh(startH)}:00–${hh(endH)}:00`;
}

// ライン×品番ごとの「生産があった時間帯(帯集合)」を作る
function buildProductTimeBands(data){
  const groupHours = parseInt(hourGroup.value);
  const bands = {}; // bands[line][product] = Set([...hourBands])

  data.forEach(r => {
    let dt = null;
    if (r.ts){ dt = parseClientDate(r.ts); }
    if (!dt && r.readAt && r.readAt.seconds){ dt = new Date(r.readAt.seconds*1000); }
    if (!dt) return;

    const line = r.line || "不明";
    const product = r.sliced || "不明";
    const band = makeHourBand(dt, groupHours);

    if (!bands[line]) bands[line] = {};
    if (!bands[line][product]) bands[line][product] = new Set();
    bands[line][product].add(band);
  });

  // Set → Array(昇順) に揃える
  Object.keys(bands).forEach(line=>{
    Object.keys(bands[line]).forEach(p=>{
      bands[line][p] = Array.from(bands[line][p]).sort((a,b)=>a.localeCompare(b,"ja"));
    });
  });
  return bands;
}

// ======== 停止時間計算（既存想定ロジックのまま） ========
function calculateStopTime(data){
  // 例: 連続レコード間のギャップ > 10 分 を停止とみなす、等
  // 実運用の既存仕様を尊重するため、ここでは現状ロジックがある前提でサンプルを残します
  const gapMin = 10;
  const stopTimeByLine = {};
  const stopDetails = [];

  const byLine = {};
  data.forEach(r=>{
    const line = r.line || "不明";
    if(!byLine[line]) byLine[line] = [];
    byLine[line].push(r);
  });
  Object.keys(byLine).forEach(line=>{
    const rows = byLine[line].slice().sort((a,b)=>{
      const ad = getDate(a), bd = getDate(b);
      return ad - bd;
    });
    for (let i=1;i<rows.length;i++){
      const prev = getDate(rows[i-1]);
      const curr = getDate(rows[i]);
      const diffMin = (curr - prev)/60000;
      if (diffMin > gapMin){
        stopTimeByLine[line] = (stopTimeByLine[line]||0) + diffMin;
        stopDetails.push({
          line,
          start: prev,
          end: curr,
          minutes: Math.round(diffMin),
          reason: "生産ギャップ"
        });
      }
    }
  });

  const totalStopMinutes = Object.values(stopTimeByLine).reduce((s,v)=>s+v,0);
  return { stopTimeByLine, totalStopMinutes, stopDetails };

  function getDate(r){
    if (r.ts){
      const d = parseClientDate(r.ts);
      if (d) return d;
    }
    if (r.readAt && r.readAt.seconds) return new Date(r.readAt.seconds*1000);
    return new Date(0);
  }
}

// ======== ダッシュボード更新（★最小改修で productBands を追加） ========
function updateDashboard(){
  const filtered = getFilteredData();

  // 停止時間計算（既存）
  const { stopTimeByLine, totalStopMinutes, stopDetails } = calculateStopTime(filtered);

  // ★追加：製品ごとの時間帯バンドを算出
  const productBands = buildProductTimeBands(filtered);

  // 既存更新処理（第3引数に productBands を追加）
  updateLineSummaryCards(filtered, stopTimeByLine, productBands);
  updateTimeSeriesChart(filtered);
  updateStopTimeChart(stopTimeByLine);
  updateStopDetailTable(stopDetails);
  updateHourlyTable(filtered);
}

// ======== サマリーカード（★製品ごとの時間帯バッジ表示） ========
function updateLineSummaryCards(data, stopTimeByLine, productBands){
  const lineProducts = {};
  data.forEach(r => {
    const line = r.line || "不明";
    const product = r.sliced || "不明";
    if (!lineProducts[line]) lineProducts[line] = {};
    if (!lineProducts[line][product]) lineProducts[line][product] = 0;
    lineProducts[line][product] += getQuantity(r.sliced);
  });

  const container = document.getElementById('lineSummaryCards');
  container.innerHTML = '';

  const sortedLines = Object.keys(lineProducts).sort();
  sortedLines.forEach(line => {
    const products = lineProducts[line];
    const totalQty = Object.values(products).reduce((s, q)=>s+q, 0);
    const stopTime = stopTimeByLine[line] || 0;

    const card = document.createElement('div');
    card.className = 'line-card';

    const sortedProducts = Object.entries(products).sort((a,b)=>b[1]-a[1]);

    // 各製品の時間帯バッジを作成
    const productRows = sortedProducts.map(([product, qty])=>{
      const bands = (productBands?.[line]?.[product]) || [];
      const badges = bands.map(b=>`<span class="time-badge">${b}</span>`).join('');
      return `
        <div class="product-item" style="flex-direction:column; align-items:flex-start; gap:6px;">
          <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <span class="product-name">${product}</span>
            <span class="product-qty">${qty.toLocaleString()}</span>
          </div>
          <div class="time-badges">${badges || '<span class="small">（時間帯データなし）</span>'}</div>
        </div>
      `;
    }).join('');

    card.innerHTML = `
      <div class="line-card-header">${line}</div>
      ${productRows}
      <div class="line-card-footer">
        <span>合計: <strong>${totalQty.toLocaleString()}</strong>個</span>
        <span class="highlight-stop">停止: ${(stopTime / 60).toFixed(1)}時間</span>
      </div>
    `;
    container.appendChild(card);
  });
}

// ======== 時系列チャート（既存） ========
function updateTimeSeriesChart(data){
  const groupHours = parseInt(hourGroup.value);
  const buckets = {}; // "YYYY-MM-DD HH:00" 単位
  data.forEach(r=>{
    const d = r.ts ? parseClientDate(r.ts)
                   : (r.readAt && r.readAt.seconds ? new Date(r.readAt.seconds*1000) : null);
    if(!d) return;
    const h = Math.floor(d.getHours()/groupHours)*groupHours;
    const key = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(h)}:00`;
    buckets[key] = (buckets[key]||0)+1;
  });
  const labels = Object.keys(buckets).sort();
  const values = labels.map(k=>buckets[k]);

  if (chart1){ chart1.destroy(); }
  const ctx = document.getElementById('timeSeriesChart');
  chart1 = new Chart(ctx, {
    type:'line',
    data:{
      labels,
      datasets:[{ label:'件数', data:values }]
    },
    options:{ responsive:true, maintainAspectRatio:false, scales:{ y:{ beginAtZero:true } } }
  });
}

function pad(n){ return String(n).padStart(2,'0'); }

// ======== 停止時間チャート（既存） ========
function updateStopTimeChart(stopTimeByLine){
  const labels = Object.keys(stopTimeByLine).sort();
  const values = labels.map(l=>Math.round(stopTimeByLine[l]));

  if (chart2){ chart2.destroy(); }
  const ctx = document.getElementById('stopTimeChart');
  chart2 = new Chart(ctx, {
    type:'bar',
    data:{
      labels,
      datasets:[{ label:'停止分', data:values }]
    },
    options:{ responsive:true, maintainAspectRatio:false, scales:{ y:{ beginAtZero:true } } }
  });
}

// ======== 停止内訳テーブル（既存） ========
function updateStopDetailTable(rows){
  const tbody = document.querySelector('#stopDetailTable tbody');
  const totalEl = document.getElementById('stopTotal');
  tbody.innerHTML = '';
  let total = 0;
  rows.sort((a,b)=>a.start - b.start).forEach(r=>{
    total += (r.minutes||0);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${escapeHTML(r.line||"不明")}</td>
      <td>${fmtDT(r.start)}</td>
      <td>${fmtDT(r.end)}</td>
      <td>${r.minutes||0}</td>
      <td>${escapeHTML(r.reason||"")}</td>
    `;
    tbody.appendChild(tr);
  });
  totalEl.textContent = total.toLocaleString();
}
function fmtDT(d){
  if (!d) return '';
  const z = n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())} ${z(d.getHours())}:${z(d.getMinutes())}`;
}

// ======== 時間帯テーブル（既存） ========
function updateHourlyTable(data){
  const groupHours = parseInt(hourGroup.value);

  // 時間帯ラベル生成
  const bands = [];
  for(let h=0; h<24; h+=groupHours){
    const s = `${pad(h)}:00`;
    const e = `${pad((h+groupHours)%24)}:00`;
    bands.push(`${s}–${e}`);
  }

  // ライン×品番×バンドでカウント
  const cube = {}; // cube[line][product][band] = count
  data.forEach(r=>{
    const d = r.ts ? parseClientDate(r.ts)
                   : (r.readAt && r.readAt.seconds ? new Date(r.readAt.seconds*1000) : null);
    if(!d) return;
    const h = d.getHours();
    const startH = Math.floor(h/groupHours)*groupHours;
    const band = `${pad(startH)}:00–${pad((startH+groupHours)%24)}:00`;
    const line = r.line || "不明";
    const product = r.sliced || "不明";
    if (!cube[line]) cube[line] = {};
    if (!cube[line][product]) cube[line][product] = {};
    cube[line][product][band] = (cube[line][product][band]||0) + getQuantity(r.sliced);
  });

  const thead = document.querySelector('#hourlyTable thead');
  const tbody = document.querySelector('#hourlyTable tbody');

  thead.innerHTML = `<tr>
    <th>ライン</th><th>品番</th>${bands.map(b=>`<th>${b}</th>`).join('')}<th>計</th>
  </tr>`;
  tbody.innerHTML = '';

  Object.keys(cube).sort().forEach(line=>{
    Object.keys(cube[line]).sort().forEach(product=>{
      const row = cube[line][product];
      let sum = 0;
      const tds = bands.map(b=>{
        const v = row[b]||0; sum += v; return `<td>${v||''}</td>`;
      }).join('');
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${escapeHTML(line)}</td><td>${escapeHTML(product)}</td>${tds}<td>${sum||''}</td>`;
      tbody.appendChild(tr);
    });
  });
}

// ======== イベント ========
refreshBtn.addEventListener('click', updateDashboard);
hourGroup.addEventListener('change', updateDashboard);
fromDate.addEventListener('change', updateDashboard);
toDate.addEventListener('change', updateDashboard);
lineFilter.addEventListener('change', updateDashboard);
productFilter.addEventListener('input', updateDashboard);

// ======== モックデータ（デモ用） ========
function generateMock(){
  const lines = ["53-300","57-200","65-300","89-400"];
  const products = ["7E0346-7020","7G0933-002","34318-12020","90-600-A"];
  const out = [];
  const now = new Date();
  for (let d=0; d<5; d++){
    for (let i=0; i<300; i++){
      const dt = new Date(now.getFullYear(), now.getMonth(), now.getDate()-d, Math.floor(Math.random()*24), Math.floor(Math.random()*60));
      out.push({
        line: lines[Math.floor(Math.random()*lines.length)],
        sliced: products[Math.floor(Math.random()*products.length)],
        ts: `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}:00`,
        readAt: { seconds: Math.floor(dt.getTime()/1000) }
      });
    }
  }
  return out;
}

</script>
</body>
</html>
