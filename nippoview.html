<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>検査日報 - 閲覧専用</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --border:#d1d5db; --muted:#6b7280; --ink:#111827; --accent:#374151; }
  *{ box-sizing: border-box; margin:0; padding:0; }
  html,body{ height:100%; }
  body{ font-family:system-ui,"Noto Sans JP",sans-serif; background:#f5f5f5; color:var(--ink); }
  
  /* Login Screen */
  #login-screen{ display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#e5e7eb; z-index:9999; }
  #login-screen.active{ display:flex; align-items:center; justify-content:center; }
  .login-card{ background:#fff; border-radius:4px; padding:40px; max-width:400px; width:90%; box-shadow:0 4px 12px rgba(0,0,0,.15); border:1px solid var(--border); }
  .login-title{ font-size:22px; font-weight:600; text-align:center; margin-bottom:30px; color:#111827; letter-spacing:-0.5px; }
  .login-group{ margin-bottom:20px; }
  .login-label{ display:block; font-weight:500; margin-bottom:8px; color:#374151; font-size:13px; }
  .login-input{ width:100%; padding:11px 12px; border:1px solid var(--border); border-radius:2px; font-size:14px; background:#fff; }
  .login-input:focus{ outline:none; border-color:#4b5563; box-shadow:0 0 0 1px #4b5563; }
  .login-btn{ width:100%; padding:13px; background:#111827; color:#fff; border:none; border-radius:2px; font-size:14px; font-weight:500; cursor:pointer; margin-top:10px; letter-spacing:0.3px; }
  .login-btn:hover{ background:#1f2937; }
  .login-error{ background:#fee; color:#991b1b; padding:12px; border-radius:2px; margin-bottom:20px; font-size:13px; display:none; border:1px solid #fca5a5; }
  
  /* Header */
  header{ position:sticky; top:0; z-index:10; background:#111827; border-bottom:1px solid #000; box-shadow:0 1px 3px rgba(0,0,0,.1); }
  .header-content{ max-width:1600px; margin:0 auto; padding:16px 20px; display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; }
  h1{ font-size:18px; color:#fff; font-weight:500; letter-spacing:-0.3px; }
  .user-info{ display:flex; align-items:center; gap:12px; padding:6px 14px; background:#1f2937; border-radius:2px; font-size:13px; color:#e5e7eb; }
  .logout-btn{ padding:7px 14px; background:#374151; color:#fff; border:none; border-radius:2px; font-size:12px; cursor:pointer; font-weight:500; }
  .logout-btn:hover{ background:#4b5563; }
  
  /* Main Content */
  main{ max-width:1600px; margin:0 auto; padding:20px; }
  
  /* Filters */
  .filters{ background:#fff; border-radius:2px; padding:20px; margin-bottom:12px; box-shadow:0 1px 3px rgba(0,0,0,.08); border:1px solid var(--border); }
  .filter-row{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:16px; margin-bottom:16px; }
  .filter-group{ display:flex; flex-direction:column; gap:6px; }
  .filter-label{ font-size:12px; font-weight:500; color:#374151; text-transform:uppercase; letter-spacing:0.5px; }
  .filter-input{ padding:9px 11px; border:1px solid var(--border); border-radius:2px; font-size:14px; background:#fff; }
  .filter-input:focus{ outline:none; border-color:#4b5563; box-shadow:0 0 0 1px #4b5563; }
  .filter-actions{ display:flex; gap:10px; flex-wrap:wrap; }
  .btn{ padding:9px 18px; border:none; border-radius:2px; font-size:13px; font-weight:500; cursor:pointer; letter-spacing:0.3px; }
  .btn-primary{ background:#111827; color:#fff; }
  .btn-primary:hover{ background:#1f2937; }
  .btn-secondary{ background:#6b7280; color:#fff; }
  .btn-secondary:hover{ background:#4b5563; }
  .btn-success{ background:#374151; color:#fff; }
  .btn-success:hover{ background:#4b5563; }
  .date-shortcuts{ display:flex; gap:8px; }
  .date-shortcut-btn{ padding:8px 12px; background:#fff; border:1px solid var(--border); border-radius:2px; font-size:12px; cursor:pointer; font-weight:500; color:#374151; }
  .date-shortcut-btn:hover{ background:#f9fafb; border-color:#4b5563; }

  /* Tabs */
  .tabs{
    margin:0 0 12px;
    display:flex;
    gap:4px;
    border-bottom:1px solid var(--border);
  }
  .tab-button{
    padding:8px 16px;
    border:none;
    border-radius:2px 2px 0 0;
    background:#e5e7eb;
    color:#374151;
    cursor:pointer;
    font-size:13px;
    font-weight:500;
  }
  .tab-button.active{
    background:#fff;
    border-bottom:2px solid #111827;
    color:#111827;
  }
  .tab-content{ display:none; }
  .tab-content.active{ display:block; }
  
  /* Stats */
  .stats{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:16px; margin-bottom:20px; }
  .stat-card{ background:#fff; border-radius:2px; padding:20px; box-shadow:0 1px 3px rgba(0,0,0,.08); border:1px solid var(--border); }
  .stat-label{ font-size:11px; color:#6b7280; margin-bottom:8px; text-transform:uppercase; letter-spacing:0.8px; font-weight:500; }
  .stat-value{ font-size:28px; font-weight:600; color:#111827; letter-spacing:-1px; }
  
  /* Product Defects Section */
  .defect-section{ background:#fff; border-radius:2px; padding:20px; margin-bottom:20px; box-shadow:0 1px 3px rgba(0,0,0,.08); border:1px solid var(--border); }
  .defect-section-title{ font-size:14px; font-weight:600; color:#111827; margin-bottom:16px; text-transform:uppercase; letter-spacing:0.5px; display:flex; justify-content:space-between; align-items:center; }
  .clear-checks-btn{ padding:6px 12px; background:#6b7280; color:#fff; border:none; border-radius:2px; font-size:11px; cursor:pointer; font-weight:500; text-transform:none; letter-spacing:0; }
  .clear-checks-btn:hover{ background:#4b5563; }
  .product-grid{ display:grid; grid-template-columns:repeat(auto-fill, 340px); gap:16px; justify-content:start; }
  .product-card{ background:#f9fafb; border:1px solid #e5e7eb; border-radius:2px; padding:16px; transition:all 0.2s; position:relative; display:flex; flex-direction:column; }
  .product-card.completed{ background:#f3f4f6; opacity:0.7; }
  .product-card.alert-high{ border-left:4px solid #dc2626; background:#fef2f2; }
  .product-card.alert-medium{ border-left:4px solid #f59e0b; background:#fefce8; }
  .alert-message{ font-size:11px; padding:6px 8px; margin-bottom:8px; border-radius:2px; line-height:1.4; }
  .alert-message.high{ background:#fee2e2; color:#991b1b; border:1px solid #fca5a5; }
  .alert-message.medium{ background:#fef3c7; color:#92400e; border:1px solid #fde68a; }
  .alert-message-icon{ display:inline-block; margin-right:4px; }
  .product-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:2px solid #111827; }
  .product-name{ font-size:16px; font-weight:600; color:#111827; }
  .product-checkbox{ display:flex; align-items:center; gap:8px; }
  .product-checkbox input[type="checkbox"]{ width:18px; height:18px; cursor:pointer; }
  .product-checkbox label{ font-size:11px; color:#6b7280; cursor:pointer; user-select:none; }
  .product-stats{ font-size:11px; color:#6b7280; }
  .product-info{ background:#fff; padding:12px; margin-bottom:12px; border-radius:2px; border:1px solid #e5e7eb; }
  .product-info-row{ display:flex; justify-content:space-between; padding:4px 0; font-size:12px; }
  .product-info-label{ color:#6b7280; }
  .product-info-value{ font-weight:500; color:#111827; }
  .defect-list{ margin-top:12px; }
  .defect-item{ display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid #e5e7eb; }
  .defect-item:last-child{ border-bottom:none; }
  .defect-name{ font-size:13px; color:#374151; }
  .defect-count{ font-size:14px; font-weight:600; color:#111827; min-width:40px; text-align:right; }
  .defect-rate-badge{ display:inline-block; padding:2px 8px; border-radius:2px; font-size:11px; font-weight:500; margin-left:8px; }
  .defect-rate-low{ background:#f0fdf4; color:#166534; }
  .defect-rate-medium{ background:#fef3c7; color:#92400e; }
  .defect-rate-high{ background:#fee; color:#991b1b; }
  .no-defects{ text-align:center; padding:20px; color:#9ca3af; font-size:13px; }

  .card-spacer{ flex:1 1 auto; }
  .remarks{ background:#fff; border:1px solid #e5e7eb; border-radius:2px; padding:12px; margin-top:12px; }
  .remarks-header{ display:flex; align-items:center; gap:8px; font-weight:600; font-size:13px; color:#111827; margin-bottom:8px; }
  .remarks-count{ font-size:11px; color:#6b7280; background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 6px; border-radius:999px; }
  .remarks-list{ list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
  .remarks-item{ font-size:12px; color:#374151; line-height:1.4; background:#f9fafb; border:1px solid #e5e7eb; border-radius:2px; padding:6px 8px; }
  .remarks-more{ margin-top:6px; }
  .remarks-more > summary{ cursor:pointer; font-size:12px; color:#374151; }

  /* Table */
  .table-container{ background:#fff; border-radius:2px; padding:20px; box-shadow:0 1px 3px rgba(0,0,0,.08); overflow-x:auto; border:1px solid var(--border); }
  .data-table{ width:100%; border-collapse:collapse; }
  .data-table th{ background:#111827; color:#fff; padding:12px 8px; text-align:center; font-weight:500; font-size:11px; white-space:nowrap; position:sticky; top:0; text-transform:uppercase; letter-spacing:0.5px; }
  .data-table th.ng{ background:#374151; }
  .data-table th.inspector{ background:#1f2937; }
  .data-table td{ padding:12px 8px; text-align:center; border-bottom:1px solid #e5e7eb; font-size:13px; white-space:nowrap; }
  .data-table td.ng{ background:#f9fafb; font-weight:500; color:#374151; }
  .data-table td.inspector{ background:#f3f4f6; font-weight:500; color:#1f2937; }
  .data-table tr:hover td{ background:#fafafa; }
  .empty{ text-align:center; padding:60px 20px; color:#9ca3af; font-size:14px; }

  /* ▼ 解析タブ：品番別 不良推移 */
  .trend-section{
    background:#fff;
    border-radius:2px;
    padding:20px;
    margin-bottom:20px;
    box-shadow:0 1px 3px rgba(0,0,0,.08);
    border:1px solid var(--border);
  }
  .trend-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
    font-size:14px;
    font-weight:600;
    color:#111827;
    text-transform:uppercase;
    letter-spacing:0.5px;
    gap:8px;
  }
  .trend-product-label{
    font-size:12px;
    font-weight:500;
    color:#374151;
  }
  .trend-note{
    margin-top:8px;
    font-size:11px;
    color:#6b7280;
  }
  .trend-empty{
    text-align:center;
    padding:30px 10px;
    font-size:13px;
    color:#9ca3af;
  }
  .trend-chart-wrapper{
    position:relative;
    width:100%;
    min-height:520px;  /* 高さ2倍 */
  }
  .trend-chart-wrapper canvas{
    width:100% !important;
    height:520px !important; /* 高さ2倍 */
  }

  @media(max-width:768px){
    .header-content{ flex-direction:column; align-items:stretch; }
    h1{ font-size:16px; }
    .filter-row{ grid-template-columns:1fr; }
    .stats{ grid-template-columns:1fr; }
    .trend-header{ flex-direction:column; align-items:flex-start; }
  }
</style>
</head>
<body>

<!-- ログイン画面 -->
<div id="login-screen" class="active">
  <div class="login-card">
    <h2 class="login-title">検査日報 閲覧システム</h2>
    <div id="login-error" class="login-error"></div>
    <div class="login-group">
      <label class="login-label">メールアドレス</label>
      <input type="email" class="login-input" id="login-email" placeholder="user@example.com">
    </div>
    <div class="login-group">
      <label class="login-label">パスワード</label>
      <input type="password" class="login-input" id="login-password" placeholder="パスワードを入力">
    </div>
    <button class="login-btn" onclick="login()">ログイン</button>
  </div>
</div>

<!-- ヘッダー -->
<header>
  <div class="header-content">
    <h1>検査日報 - 閲覧システム</h1>
    <div class="user-info" id="user-info" style="display:none;">
      <span id="user-email"></span>
      <button class="logout-btn" onclick="logout()">ログアウト</button>
    </div>
  </div>
</header>

<!-- メインコンテンツ -->
<main>
  <!-- フィルター（共通） -->
  <div class="filters">
    <div class="filter-row">
      <div class="filter-group">
        <label class="filter-label">開始日</label>
        <input type="date" class="filter-input" id="filter-start-date">
      </div>
      <div class="filter-group">
        <label class="filter-label">終了日</label>
        <input type="date" class="filter-input" id="filter-end-date">
      </div>
      <div class="filter-group">
        <label class="filter-label">整理No</label>
        <select class="filter-input" id="filter-product">
          <option value="">すべて</option>
        </select>
      </div>
      <div class="filter-group">
        <label class="filter-label">検査種類</label>
        <select class="filter-input" id="filter-type">
          <option value="">すべて</option>
          <option value="通常検査">通常検査</option>
          <option value="F">F - 初期流動</option>
          <option value="S">S - 選別</option>
          <option value="K">K - 工程変更</option>
          <option value="C">C - 新人Wチェック</option>
          <option value="H">H - 箱詰め</option>
          <option value="G">G - 外観検査</option>
          <option value="R">R - 穴バリ検査</option>
          <option value="Z">Z - 画像検査+梱包</option>
        </select>
      </div>
    </div>
    <div class="filter-actions">
      <button class="date-shortcut-btn" onclick="filterToday()">今日</button>
      <button class="date-shortcut-btn" onclick="filterYesterday()">昨日</button>
      <button class="date-shortcut-btn" onclick="filterThisWeek()">今週</button>
      <button class="date-shortcut-btn" onclick="filterThisMonth()">今月</button>
      <button class="btn btn-primary" onclick="applyFilters()">絞り込み</button>
      <button class="btn btn-secondary" onclick="clearFilters()">クリア</button>
      <button class="btn btn-success" onclick="exportCSV()">CSV出力</button>
    </div>
  </div>

  <!-- タブ -->
  <div class="tabs">
    <button class="tab-button active" data-tab="tab-main" onclick="switchTab('tab-main')">一覧</button>
    <button class="tab-button" data-tab="tab-analysis" onclick="switchTab('tab-analysis')">解析</button>
  </div>

  <!-- ▼ 一覧タブ -->
  <div id="tab-main" class="tab-content active">

    <!-- 統計 -->
    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">総レコード数</div>
        <div class="stat-value" id="stat-total">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">合計検査数</div>
        <div class="stat-value" id="stat-inspection">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">合計不良数</div>
        <div class="stat-value" id="stat-defect">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">不良率</div>
        <div class="stat-value" id="stat-defect-rate">0%</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">合計検査時間</div>
        <div class="stat-value" id="stat-time">0時間</div>
      </div>
    </div>
    
    <!-- 製品別不良集計 -->
    <div class="defect-section">
      <div class="defect-section-title">
        <span>製品別不良集計</span>
        <button class="clear-checks-btn" onclick="clearAllChecks()">すべてのチェックを解除</button>
      </div>
      <div class="product-grid" id="product-defects"></div>
    </div>
    
    <!-- データテーブル -->
    <div class="table-container">
      <table class="data-table">
        <thead id="table-head"></thead>
        <tbody id="table-body"></tbody>
      </table>
      <div id="empty-state" class="empty" style="display:none;">
        <p>データがありません</p>
      </div>
    </div>
  </div>

  <!-- ▼ 解析タブ -->
  <div id="tab-analysis" class="tab-content">
    <div class="trend-section">
      <div class="trend-header">
        <span>品番別 不良推移</span>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
          <select id="trend-xaxis"
            class="filter-input"
            style="width:auto;padding:4px 8px;font-size:12px;height:auto;"
            onchange="updateDefectTrend()">
            <option value="date">検査日</option>
            <option value="lot">ロットNo</option>
          </select>
          <span id="trend-product-label" class="trend-product-label">
            （整理Noを選択して「絞り込み」を押すと表示）
          </span>
        </div>
      </div>
      <div class="trend-chart-wrapper">
        <canvas id="defectTrendChart"></canvas>
        <div id="trend-empty" class="trend-empty" style="display:none;">
          対象データがありません
        </div>
      </div>
      <div class="trend-note">
        ・上部フィルタの「整理No」で品番を選択し、期間を指定して「絞り込み」を押すと、<br>
        &emsp;その品番の <strong>不良数（棒グラフ）</strong> と <strong>不良率（折れ線）</strong> を表示します。<br>
        ・「横軸」を <strong>検査日 / ロットNo</strong> で切り替えることで、見たい軸で推移を確認できます。<br>
        ・ロット軸のときは、ロットNoの<strong>3桁目</strong>から月を読み取り、月順（1〜12月）に並び替えています。
      </div>
    </div>
  </div>

</main>

<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyAOMRoojKv9Hnh3OjVGwYV_k1LBTGOKepY",
  authDomain: "miyamaunitec-fb87a.firebaseapp.com",
  projectId: "miyamaunitec-fb87a",
  storageBucket: "miyamaunitec-fb87a.firebasestorage.app",
  messagingSenderId: "495316649507",
  appId: "1:495316649507:web:fa195645f46e41b1a39396"
};

let db, auth;
let currentUser = null;
let allData = [];
let filteredData = [];
let cols = new Map();
let master = {};
let autoLogoutTimer = null;
let defectTrendChart = null; // 解析タブのチャート

try {
  firebase.initializeApp(firebaseConfig);
  db = firebase.firestore();
  auth = firebase.auth();
  
  auth.onAuthStateChanged(user => {
    if (user) {
      currentUser = user;
      document.getElementById('login-screen').classList.remove('active');
      document.getElementById('user-email').textContent = user.email;
      document.getElementById('user-info').style.display = 'flex';
      initApp();
      resetAutoLogout();
    } else {
      currentUser = null;
      document.getElementById('login-screen').classList.add('active');
      document.getElementById('user-info').style.display = 'none';
      clearAutoLogout();
    }
  });
} catch (error) {
  console.error('Firebase初期化エラー:', error);
  alert('Firebaseに接続できません');
}

async function login() {
  const email = document.getElementById('login-email').value.trim();
  const password = document.getElementById('login-password').value;
  const errorDiv = document.getElementById('login-error');
  
  if (!email || !password) {
    errorDiv.textContent = 'メールアドレスとパスワードを入力してください';
    errorDiv.style.display = 'block';
    return;
  }
  
  try {
    await auth.signInWithEmailAndPassword(email, password);
    errorDiv.style.display = 'none';
  } catch (error) {
    let message = 'ログインに失敗しました';
    if (error.code === 'auth/user-not-found') message = 'ユーザーが見つかりません';
    else if (error.code === 'auth/wrong-password') message = 'パスワードが正しくありません';
    else if (error.code === 'auth/invalid-email') message = 'メールアドレスの形式が正しくありません';
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }
}

async function logout() {
  if (confirm('ログアウトしますか?')) {
    await auth.signOut();
  }
}

function resetAutoLogout() {
  clearAutoLogout();
  autoLogoutTimer = setTimeout(() => {
    alert('30分間操作がなかったため、自動的にログアウトします。');
    logout();
  }, 30 * 60 * 1000);
}

function clearAutoLogout() {
  if (autoLogoutTimer) {
    clearTimeout(autoLogoutTimer);
    autoLogoutTimer = null;
  }
}

document.addEventListener('click', resetAutoLogout);
document.addEventListener('keypress', resetAutoLogout);
document.getElementById('login-password').addEventListener('keypress', e => {
  if (e.key === 'Enter') login();
});

/* ▼ 日付ショートカット */
function filterToday() {
  const today = new Date().toISOString().split('T')[0];
  document.getElementById('filter-start-date').value = today;
  document.getElementById('filter-end-date').value = today;
  applyFilters();
}

function filterYesterday() {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const dateStr = yesterday.toISOString().split('T')[0];
  document.getElementById('filter-start-date').value = dateStr;
  document.getElementById('filter-end-date').value = dateStr;
  applyFilters();
}

function filterThisWeek() {
  const today = new Date();
  const dayOfWeek = today.getDay();
  const monday = new Date(today);
  monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
  
  document.getElementById('filter-start-date').value = monday.toISOString().split('T')[0];
  document.getElementById('filter-end-date').value = today.toISOString().split('T')[0];
  applyFilters();
}

function filterThisMonth() {
  const today = new Date();
  const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
  
  document.getElementById('filter-start-date').value = firstDay.toISOString().split('T')[0];
  document.getElementById('filter-end-date').value = today.toISOString().split('T')[0];
  applyFilters();
}

/* ▼ タブ切替 */
function switchTab(tabId){
  document.querySelectorAll('.tab-button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabId);
  });
  document.querySelectorAll('.tab-content').forEach(el => {
    el.classList.toggle('active', el.id === tabId);
  });

  if (tabId === 'tab-analysis') {
    updateDefectTrend();
  }
}

/* ▼ チェックボックス状態保持関連 */
function saveCheckState(productCode, date, checked) {
  const key = `check_${currentUser ? currentUser.uid : 'guest'}_${date}_${productCode}`;
  if (checked) {
    localStorage.setItem(key, 'true');
  } else {
    localStorage.removeItem(key);
  }
}

function getCheckState(productCode, date) {
  const key = `check_${currentUser ? currentUser.uid : 'guest'}_${date}_${productCode}`;
  return localStorage.getItem(key) === 'true';
}

function clearAllChecks() {
  if (confirm('すべての入力完了チェックを解除しますか?')) {
    const startDate = document.getElementById('filter-start-date').value;
    const endDate = document.getElementById('filter-end-date').value;
    const dateKey = `${startDate}_${endDate}`;
    
    const checkboxes = document.querySelectorAll('.product-complete-check');
    checkboxes.forEach(checkbox => {
      const productCode = checkbox.dataset.product;
      checkbox.checked = false;
      saveCheckState(productCode, dateKey, false);
      
      const card = checkbox.closest('.product-card');
      if (card) {
        card.classList.remove('completed');
      }
    });
  }
}

function handleCheckChange(checkbox, productCode) {
  const startDate = document.getElementById('filter-start-date').value;
  const endDate = document.getElementById('filter-end-date').value;
  const dateKey = `${startDate}_${endDate}`;
  
  saveCheckState(productCode, dateKey, checkbox.checked);
  
  const card = checkbox.closest('.product-card');
  if (card) {
    if (checkbox.checked) {
      card.classList.add('completed');
    } else {
      card.classList.remove('completed');
    }
  }
}

/* ▼ 初期化 */
function initApp() {
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];
  document.getElementById('filter-start-date').value = todayStr;
  document.getElementById('filter-end-date').value = todayStr;
  
  db.collection('productMaster').onSnapshot(snapshot => {
    master = {};
    snapshot.forEach(doc => {
      master[doc.id] = doc.data().ngItems || [];
    });
    updateProductFilter();
    updateCols();
    renderHeader();
  });
  
  db.collection('dailyReports').orderBy('timestamp', 'desc').onSnapshot(snapshot => {
    allData = [];
    snapshot.forEach(doc => {
      const d = doc.data();
      allData.push({
        id: doc.id,
        pd: d.pd || '',
        on: d.on || '',
        pieces: d.pieces || '',
        boxes: d.boxes || '',
        remainder: d.remainder || '',
        ic: d.ic || '0',
        totalTime: d.totalTime || '0',
        ln: d.ln || '',
        it2: d.it2 || '',
        inspectors: d.inspectors || [],
        ngMap: d.ngMap ? new Map(Object.entries(d.ngMap)) : new Map(),
        rm: d.rm || ''
      });
    });
    applyFilters();
  });
}

/* ▼ マスタ関連 */
function updateProductFilter() {
  const select = document.getElementById('filter-product');
  const currentValue = select.value;
  
  let html = '<option value="">すべて</option>';
  Object.keys(master).sort().forEach(code => {
    html += `<option value="${code}">${code}</option>`;
  });
  
  select.innerHTML = html;
  if (currentValue) select.value = currentValue;
}

function updateCols() {
  cols.clear();
  Object.values(master).forEach(items => {
    items.forEach(item => {
      cols.set(item.code, item.name);
    });
  });
}

/* ▼ 絞り込み・統計更新 */
function applyFilters() {
  const startDate = document.getElementById('filter-start-date').value;
  const endDate = document.getElementById('filter-end-date').value;
  const product = document.getElementById('filter-product').value;
  const type = document.getElementById('filter-type').value;
  
  filteredData = allData.filter(item => {
    const itemDate = item.pd.replace(/\//g, '-');
    
    if (startDate && itemDate < startDate) return false;
    if (endDate && itemDate > endDate) return false;
    if (product && item.on !== product) return false;
    if (type) {
      if (type === '通常検査') {
        if (item.it2 && item.it2 !== '') return false;
      } else {
        if (item.it2 !== type) return false;
      }
    }
    
    return true;
  });
  
  updateStats();
  renderTable();
  updateDefectTrend();
}

function clearFilters() {
  const today = new Date();
  const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
  document.getElementById('filter-start-date').value = firstDay.toISOString().split('T')[0];
  document.getElementById('filter-end-date').value = today.toISOString().split('T')[0];
  document.getElementById('filter-product').value = '';
  document.getElementById('filter-type').value = '';
  applyFilters();
}

function updateStats() {
  const totalRecords = filteredData.length;
  const totalInspection = filteredData.reduce((sum, item) => sum + parseInt(item.ic || 0), 0);
  const totalTime = filteredData.reduce((sum, item) => sum + parseInt(item.totalTime || 0), 0);
  
  const totalDefects = filteredData.reduce((sum, item) => {
    if (item.ngMap) {
      let itemDefects = 0;
      item.ngMap.forEach(value => {
        itemDefects += parseInt(value || 0);
      });
      return sum + itemDefects;
    }
    return sum;
  }, 0);
  
  const defectRate = totalInspection > 0 ? (totalDefects / totalInspection * 100).toFixed(2) : 0;
  
  const hours = Math.floor(totalTime / 60);
  const minutes = totalTime % 60;
  
  document.getElementById('stat-total').textContent = totalRecords;
  document.getElementById('stat-inspection').textContent = totalInspection.toLocaleString();
  document.getElementById('stat-defect').textContent = totalDefects.toLocaleString();
  document.getElementById('stat-defect-rate').textContent = defectRate + '%';
  document.getElementById('stat-time').textContent = hours > 0 ? `${hours}時間${minutes}分` : `${minutes}分`;
  
  renderProductDefects();
}

/* ▼ HTMLエスケープ */
function escapeHtml(s){
  if (typeof s !== 'string') return s;
  return s.replace(/[&<>"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

/* ▼ 製品別不良カード */
function renderProductDefects() {
  const productTypeDefects = {};
  const historicalData = {};

  const startDate = document.getElementById('filter-start-date').value;
  const endDate = document.getElementById('filter-end-date').value;
  const displayStart = new Date(startDate);
  const displayEnd = new Date(endDate);

  // 現期間の集計（整理No × 検査種類）
  filteredData.forEach(item => {
    const productCode = item.on || 'unknown';
    const typeKey = (item.it2 && item.it2.trim()) ? item.it2.trim() : '通常検査';
    const key = `${productCode}||${typeKey}`;

    if (!productTypeDefects[key]) {
      productTypeDefects[key] = {
        productCode,
        typeKey,
        inspection: 0,
        totalTime: 0,
        lotNumbers: new Set(),
        defects: {},
        totalDefects: 0,
        remarks: new Set()
      };
    }
    const bucket = productTypeDefects[key];

    bucket.inspection += parseInt(item.ic || 0);
    bucket.totalTime += parseInt(item.totalTime || 0);

    if (item.ln) bucket.lotNumbers.add(item.ln);
    if (item.rm && item.rm.trim()) bucket.remarks.add(item.rm.trim());

    if (item.ngMap) {
      item.ngMap.forEach((value, code) => {
        const count = parseInt(value || 0);
        if (count > 0) {
          if (!bucket.defects[code]) bucket.defects[code] = 0;
          bucket.defects[code] += count;
          bucket.totalDefects += count;
        }
      });
    }
  });

  // 直近30日（表示期間より前）の履歴
  const thirtyDaysAgo = new Date(displayStart);
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  allData.forEach(item => {
    const itemDateStr = item.pd.replace(/\//g, '-');
    const itemDate = new Date(itemDateStr);
    if (!(itemDate >= thirtyDaysAgo && itemDate < displayStart)) return;

    const productCode = item.on || 'unknown';
    const typeKey = (item.it2 && item.it2.trim()) ? item.it2.trim() : '通常検査';
    const key = `${productCode}||${typeKey}`;

    if (!historicalData[key]) {
      historicalData[key] = {
        inspection: 0,
        totalDefects: 0,
        defectCodes: new Set()
      };
    }
    const hist = historicalData[key];

    hist.inspection += parseInt(item.ic || 0);
    if (item.ngMap) {
      item.ngMap.forEach((value, code) => {
        const count = parseInt(value || 0);
        if (count > 0) {
          hist.totalDefects += count;
          hist.defectCodes.add(code);
        }
      });
    }
  });

  const TYPE_ORDER = ['通常検査','F','S','K','C','H','G','R','Z'];
  const typeRank = (t) => {
    const idx = TYPE_ORDER.indexOf(t);
    return idx === -1 ? TYPE_ORDER.length : idx;
  };

  const sorted = Object.entries(productTypeDefects).sort((a, b) => {
    const A = a[1], B = b[1];
    const pc = (A.productCode || '').localeCompare(B.productCode || '', 'ja', { numeric: true, sensitivity: 'base' });
    if (pc !== 0) return pc;
    return typeRank(A.typeKey) - typeRank(B.typeKey);
  });

  const container = document.getElementById('product-defects');
  if (sorted.length === 0) {
    container.innerHTML = '<div class="no-defects">データがありません</div>';
    return;
  }

  const startDateStr = document.getElementById('filter-start-date').value;
  const endDateStr = document.getElementById('filter-end-date').value;
  const dateKey = `${startDateStr}_${endDateStr}`;
  let html = '';

  sorted.forEach(([key, data]) => {
    const { productCode, typeKey } = data;
    const defectRate = data.inspection > 0 ? (data.totalDefects / data.inspection * 100) : 0;
    const rateClass = defectRate > 3 ? 'defect-rate-high' : defectRate > 1 ? 'defect-rate-medium' : 'defect-rate-low';

    const cardKey = `${productCode}__${typeKey}`;
    const isChecked = getCheckState(cardKey, dateKey);
    const completedClass = isChecked ? 'completed' : '';

    const alerts = [];
    const unusualDefects = [];
    let cardAlertClass = '';
    const hist = historicalData[`${productCode}||${typeKey}`];

    if (hist && hist.inspection > 0) {
      const historicalRate = (hist.totalDefects / hist.inspection) * 100;
      if (historicalRate > 0 && defectRate > historicalRate * 2) {
        alerts.push({ level: 'high', message: `不良率急増 (30日平均: ${historicalRate.toFixed(2)}% → 現在: ${defectRate.toFixed(2)}%)` });
        cardAlertClass = 'alert-high';
      } else if (historicalRate > 0 && defectRate > historicalRate * 1.5) {
        alerts.push({ level: 'medium', message: `不良率上昇 (30日平均: ${historicalRate.toFixed(2)}% → 現在: ${defectRate.toFixed(2)}%)` });
        if (!cardAlertClass) cardAlertClass = 'alert-medium';
      }

      Object.keys(data.defects).forEach(code => {
        if (!hist.defectCodes.has(code)) {
          const defectName = cols.get(code) || code;
          unusualDefects.push(`${code}: ${defectName} (${data.defects[code]}個)`);
        }
      });
      if (unusualDefects.length > 0 && !alerts.some(a => a.message.includes('不良率'))) {
        alerts.push({ level: 'medium', message: `新規NG発生: ${unusualDefects.length}件` });
        if (!cardAlertClass) cardAlertClass = 'alert-medium';
      }
    }

    const periodDays = Math.floor((displayEnd - displayStart) / (1000 * 60 * 60 * 24)) + 1;
    if (periodDays >= 7 && !alerts.some(a => a.level === 'high' || a.message.includes('上昇'))) {
      const midPoint = new Date(displayStart.getTime() + (displayEnd.getTime() - displayStart.getTime()) / 2);
      const firstHalf = { inspection: 0, defects: 0 };
      const secondHalf = { inspection: 0, defects: 0 };

      filteredData.forEach(item => {
        const type = (item.it2 && item.it2.trim()) ? item.it2.trim() : '通常検査';
        if (item.on !== productCode || type !== typeKey) return;

        const itemDate = new Date(item.pd.replace(/\//g, '-'));
        const inspection = parseInt(item.ic || 0);
        let itemDefects = 0;
        if (item.ngMap) item.ngMap.forEach(v => { itemDefects += parseInt(v || 0); });

        if (itemDate < midPoint) {
          firstHalf.inspection += inspection;
          firstHalf.defects += itemDefects;
        } else {
          secondHalf.inspection += inspection;
          secondHalf.defects += itemDefects;
        }
      });

      const firstRate = firstHalf.inspection > 0 ? (firstHalf.defects / firstHalf.inspection * 100) : 0;
      const secondRate = secondHalf.inspection > 0 ? (secondHalf.defects / secondHalf.inspection * 100) : 0;
      if (firstRate >= 0.5 && secondRate > firstRate * 1.3) {
        alerts.push({ level: 'medium', message: `増加傾向 (前半: ${firstRate.toFixed(2)}% → 後半: ${secondRate.toFixed(2)}%)` });
        if (!cardAlertClass) cardAlertClass = 'alert-medium';
      }
    }

    const totalMinutes = Number(data.totalTime || 0);
    const timeDisplay = `${totalMinutes.toLocaleString()}分`;
    const lotDisplay = Array.from(data.lotNumbers).join(', ') || '-';

    html += `<div class="product-card ${completedClass} ${cardAlertClass}">`;

    html += '<div class="product-header">';
    html += `<div class="product-name">${productCode} / ${typeKey}</div>`;
    html += '<div class="product-checkbox">';
    html += `<input type="checkbox" class="product-complete-check" data-product="${cardKey}" ${isChecked ? 'checked' : ''} onchange="handleCheckChange(this, '${cardKey}')">`;
    html += '<label onclick="event.target.previousElementSibling.click()">入力完了</label>';
    html += '</div>';
    html += '</div>';

    if (alerts.length > 0) {
      const highestLevel = alerts.some(a => a.level === 'high') ? 'high' : 'medium';
      const icon = highestLevel === 'high' ? '⚠' : '⚡';
      const primaryAlert = alerts[0];
      html += `<div class="alert-message ${highestLevel}"><span class="alert-message-icon">${icon}</span>${primaryAlert.message}</div>`;
    }

    html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">';
    html += '<div class="product-stats">';
    html += `<span class="defect-rate-badge ${rateClass}">${defectRate.toFixed(2)}%</span>`;
    html += '</div>';
    html += '</div>';

    html += '<div class="product-info">';
    html += '<div class="product-info-row"><div class="product-info-label">検査数</div>';
    html += `<div class="product-info-value">${data.inspection.toLocaleString()}個</div></div>`;
    html += '<div class="product-info-row"><div class="product-info-label">検査時間</div>';
    html += `<div class="product-info-value">${timeDisplay}</div></div>`;
    html += '<div class="product-info-row"><div class="product-info-label">検査種類</div>';
    html += `<div class="product-info-value">${typeKey}</div></div>`;
    html += '<div class="product-info-row"><div class="product-info-label">ロットNo</div>';
    html += `<div class="product-info-value" style="font-size:11px;">${lotDisplay}</div></div>`;
    html += '</div>';

    if (Object.keys(data.defects).length === 0) {
      html += '<div style="text-align:center;padding:16px;color:#9ca3af;font-size:12px;">不良なし</div>';
    } else {
      html += '<div class="defect-list">';
      const sortedDefects = Object.entries(data.defects).sort((a, b) => b[1] - a[1]);
      sortedDefects.forEach(([code, count]) => {
        const defectName = cols.get(code) || code;
        const itemRate = data.inspection > 0 ? (count / data.inspection * 100).toFixed(2) : 0;
        const isUnusual = hist ? !hist.defectCodes.has(code) : false;
        html += '<div class="defect-item">';
        html += `<div class="defect-name">${code}: ${defectName}${isUnusual ? ' ⚡' : ''}</div>`;
        html += `<div><span class="defect-count">${count}</span><span style="font-size:11px;color:#6b7280;margin-left:4px;">(${itemRate}%)</span></div>`;
        html += '</div>';
      });
      html += '</div>';

      html += '<div style="margin-top:12px;padding-top:12px;border-top:2px solid #111827;display:flex;justify-content:space-between;font-weight:600;">';
      html += '<div>合計不良数</div>';
      html += `<div>${data.totalDefects}</div>`;
      html += '</div>';
    }

    html += '<div class="card-spacer"></div>';

    const remarksAll = Array.from(data.remarks || []);
    if (remarksAll.length > 0) {
      const first = remarksAll.slice(0, 3);
      const rest  = remarksAll.slice(3);
      html += '<div class="remarks">';
      html += `<div class="remarks-header">備考 <span class="remarks-count">${remarksAll.length}件</span></div>`;
      html += '<ul class="remarks-list">';
      first.forEach(r => { html += `<li class="remarks-item">${escapeHtml(r)}</li>`; });
      html += '</ul>';
      if (rest.length > 0) {
        html += '<details class="remarks-more"><summary>もっと見る</summary><ul class="remarks-list">';
        rest.forEach(r => { html += `<li class="remarks-item">${escapeHtml(r)}</li>`; });
        html += '</ul></details>';
      }
      html += '</div>';
    }

    html += '</div>'; // .product-card
  });

  container.innerHTML = html;
}

/* ▼ テーブルヘッダ・ボディ描画 */
function renderHeader() {
  const thead = document.getElementById('table-head');
  thead.innerHTML = '';
  const row = document.createElement('tr');
  
  ['生産日付', '整理No', '検査数', '合計検査時間(分)', 'ロットNo', '検査種類', '検査員情報'].forEach(label => {
    const th = document.createElement('th');
    if (label === '検査員情報') th.className = 'inspector';
    th.textContent = label;
    row.appendChild(th);
  });
  
  Array.from(cols.entries()).sort().forEach(([code, name]) => {
    const th = document.createElement('th');
    th.className = 'ng';
    th.innerHTML = code + '<br>' + name;
    row.appendChild(th);
  });
  
  const th = document.createElement('th');
  th.textContent = '備考';
  row.appendChild(th);
  
  thead.appendChild(row);
}

function renderTable() {
  const tbody = document.getElementById('table-body');
  const emptyState = document.getElementById('empty-state');
  
  tbody.innerHTML = '';
  
  if (filteredData.length === 0) {
    emptyState.style.display = 'block';
    return;
  }
  
  emptyState.style.display = 'none';
  
  filteredData.forEach(item => {
    const row = document.createElement('tr');
    
    let inspectionCountDisplay = item.ic || '0';
    if (item.pieces && item.boxes) {
      const base = item.pieces + '個×' + item.boxes + '箱';
      inspectionCountDisplay = item.remainder ? base + '+' + item.remainder + '=' + item.ic : base + '=' + item.ic;
    }
    
    const inspectorInfo = item.inspectors && item.inspectors.length > 0 ? 
      item.inspectors.map(ins => {
        if (ins.timePeriods && ins.timePeriods.length > 0) {
          const timeInfo = ins.timePeriods.map(period => 
            period.startTime + '-' + period.endTime
          ).join(',');
          return ins.name + '(' + timeInfo + ')';
        } else if (ins.startTime && ins.endTime) {
          return ins.name + '(' + ins.startTime + '-' + ins.endTime + ')';
        } else {
          return ins.name;
        }
      }).join(', ') : '';
    
    [item.pd, item.on, inspectionCountDisplay, item.totalTime, item.ln, item.it2 || '通常検査', inspectorInfo].forEach((value, index) => {
      const td = document.createElement('td');
      if (index === 6) td.className = 'inspector';
      td.textContent = value || '';
      row.appendChild(td);
    });
    
    Array.from(cols.keys()).sort().forEach(code => {
      const td = document.createElement('td');
      td.className = 'ng';
      td.textContent = item.ngMap && item.ngMap.get(code) || '0';
      row.appendChild(td);
    });
    
    const td = document.createElement('td');
    td.textContent = item.rm || '';
    row.appendChild(td);
    
    tbody.appendChild(row);
  });
}

/* ▼ CSV出力 */
function exportCSV() {
  if (filteredData.length === 0) {
    alert('エクスポートするデータがありません');
    return;
  }
  
  const headers = ['生産日付', '整理No', '個数', '箱数', '検査数', '合計検査時間(分)', 'ロットNo', '検査種類', '検査員情報'];
  const ngCols = Array.from(cols.keys()).sort();
  const allHeaders = headers.concat(ngCols).concat(['備考']);
  
  const rows = filteredData.map(item => {
    const inspectorInfo = item.inspectors ? 
      item.inspectors.map(ins => {
        if (ins.timePeriods && ins.timePeriods.length > 0) {
          const timeInfo = ins.timePeriods.map(period => 
            period.startTime + '-' + period.endTime
          ).join(',');
          return ins.name + '(' + timeInfo + ')';
        } else if (ins.startTime && ins.endTime) {
          return ins.name + '(' + ins.startTime + '-' + ins.endTime + ')';
        } else {
          return ins.name;
        }
      }).join('; ') : '';
    
    const baseData = [
      item.pd || '', 
      item.on || '', 
      item.pieces || '', 
      item.boxes || '', 
      item.ic || '0', 
      item.totalTime || '0', 
      item.ln || '', 
      item.it2 || '通常検査', 
      inspectorInfo
    ];
    
    const ngData = ngCols.map(code => item.ngMap && item.ngMap.get(code) || '0');
    
    return baseData.concat(ngData).concat([item.rm || '']);
  });
  
  const csvContent = [allHeaders.join(',')]
    .concat(rows.map(row => row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(',')))
    .join('\n');
  
  const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
  const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'inspection_data_' + new Date().toISOString().split('T')[0] + '.csv';
  a.click();
  URL.revokeObjectURL(url);
}

/* ▼ ロットNo の3桁目 → 月に変換 */
function getMonthFromLot(lot){
  if(!lot) return 99;
  const s = lot.toString().trim();
  if(s.length < 3) return 99;          // 3文字未満は判定不可
  const ch = s[2].toUpperCase();      // 3桁目を見る

  if(ch >= '1' && ch <= '9') return parseInt(ch, 10); // 1〜9 → 1〜9月
  if(ch === '0' || ch === 'O') return 10;             // 0 / O → 10月
  if(ch === 'N') return 11;                           // N → 11月
  if(ch === 'D') return 12;                           // D → 12月

  return 99; // 判定できないものは後ろ
}

/* ▼ 品番別 不良推移（解析タブ用） */
function updateDefectTrend() {
  const productSelect = document.getElementById('filter-product');
  const productCode = productSelect.value;
  const startDate = document.getElementById('filter-start-date').value;
  const endDate   = document.getElementById('filter-end-date').value;
  const labelEl   = document.getElementById('trend-product-label');
  const emptyEl   = document.getElementById('trend-empty');
  const canvas    = document.getElementById('defectTrendChart');
  const xAxisEl   = document.getElementById('trend-xaxis');
  const xAxisMode = xAxisEl ? xAxisEl.value : 'date'; // 'date' or 'lot'

  if (!productCode) {
    labelEl.textContent = '（整理Noを選択して「絞り込み」を押してください）';
    emptyEl.style.display = 'block';
    if (defectTrendChart) {
      defectTrendChart.destroy();
      defectTrendChart = null;
    }
    return;
  }

  const axisLabel = xAxisMode === 'date' ? '検査日' : 'ロットNo';
  labelEl.textContent = `整理No：${productCode} ／ 期間：${startDate || '-'} ～ ${endDate || '-'} ／ 横軸：${axisLabel}`;

  const bucketMap = new Map(); // key -> { inspection, defects }

  filteredData.forEach(item => {
    if (item.on !== productCode) return;

    let key;
    if (xAxisMode === 'date') {
      key = item.pd.replace(/\//g, '-');
    } else {
      key = (item.ln && String(item.ln).trim()) ? String(item.ln).trim() : '(ロット未入力)';
    }

    if (!bucketMap.has(key)) {
      bucketMap.set(key, { inspection: 0, defects: 0 });
    }
    const bucket = bucketMap.get(key);

    const ic = parseInt(item.ic || 0);
    bucket.inspection += ic;

    let itemDefects = 0;
    if (item.ngMap) {
      item.ngMap.forEach(v => {
        itemDefects += parseInt(v || 0);
      });
    }
    bucket.defects += itemDefects;
  });

  let labels;
  if (xAxisMode === 'lot') {
    // ロット軸：3桁目→月でソート
    labels = Array.from(bucketMap.keys()).sort((a, b) => {
      const ma = getMonthFromLot(a);
      const mb = getMonthFromLot(b);
      if (ma !== mb) return ma - mb;
      return a.localeCompare(b, 'ja', { numeric:true, sensitivity:'base' });
    });
  } else {
    // 検査日：日付文字列でソート（YYYY-MM-DD 前提）
    labels = Array.from(bucketMap.keys()).sort();
  }

  if (labels.length === 0) {
    emptyEl.style.display = 'block';
    if (defectTrendChart) {
      defectTrendChart.destroy();
      defectTrendChart = null;
    }
    return;
  } else {
    emptyEl.style.display = 'none';
  }

  const defectCounts = labels.map(k => bucketMap.get(k).defects);
  const defectRates  = labels.map(k => {
    const b = bucketMap.get(k);
    return b.inspection > 0 ? +(b.defects / b.inspection * 100).toFixed(2) : 0;
  });

  // 不良率が高いところを強調
  const HIGH_THRESHOLD = 3; // 3%以上を「高い」とする（必要なら調整）
  const MED_THRESHOLD  = 1; // 1%以上を中程度

  const barBgColors = defectRates.map(rate => {
    if (rate >= HIGH_THRESHOLD) return 'rgba(220,38,38,0.7)';     // 赤系（高い）
    if (rate >= MED_THRESHOLD)  return 'rgba(245,158,11,0.7)';    // オレンジ系（中）
    return 'rgba(55,65,81,0.7)';                                  // グレー（低）
  });
  const barBorderColors = defectRates.map(rate => {
    if (rate >= HIGH_THRESHOLD) return 'rgba(185,28,28,1)';
    if (rate >= MED_THRESHOLD)  return 'rgba(217,119,6,1)';
    return 'rgba(31,41,55,1)';
  });

  const lineColors = defectRates.map(rate => {
    if (rate >= HIGH_THRESHOLD) return 'rgba(220,38,38,1)';
    if (rate >= MED_THRESHOLD)  return 'rgba(245,158,11,1)';
    return 'rgba(37,99,235,1)'; // 通常は青
  });

  if (defectTrendChart) {
    defectTrendChart.destroy();
  }

  const ctx = canvas.getContext('2d');
  const isLotAxis = (xAxisMode === 'lot');

  defectTrendChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          type: 'bar',
          label: '不良数（個）',
          data: defectCounts,
          yAxisID: 'y',
          backgroundColor: barBgColors,
          borderColor: barBorderColors,
          borderWidth: 1
        },
        {
          type: 'line',
          label: '不良率（％）',
          data: defectRates,
          yAxisID: 'y1',
          tension: 0.2,
          pointRadius: 3,
          borderColor: 'rgba(37,99,235,1)',
          backgroundColor: 'rgba(37,99,235,0.2)',
          pointBackgroundColor: lineColors,
          pointBorderColor: lineColors
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'index',
        intersect: false
      },
      scales: {
        x: {
          title: {
            display: true,
            text: axisLabel
          },
          ticks: {
            autoSkip: !isLotAxis,          // ロットのときは autoSkip しない（全部表示）
            maxRotation: isLotAxis ? 45 : 0,
            minRotation: isLotAxis ? 45 : 0
          }
        },
        y: {
          position: 'left',
          title: { display: true, text: '不良数（個）' },
          beginAtZero: true
        },
        y1: {
          position: 'right',
          title: { display: true, text: '不良率（％）' },
          beginAtZero: true,
          grid: { drawOnChartArea: false }
        }
      },
      plugins: {
        legend: { display: true },
        tooltip: {
          callbacks: {
            label: function(context){
              if (context.datasetIndex === 0) {
                return `不良数: ${context.parsed.y}個`;
              } else {
                return `不良率: ${context.parsed.y.toFixed(2)}%`;
              }
            }
          }
        }
      }
    }
  });
}
</script>
</body>
</html>
