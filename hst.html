
<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ヒストグラム生成ツール</title>
<style>

:root {
  --primary: #2563eb;
  --accent: #10b981;
  --danger: #ef4444;
  --background: #f4f6fb;
  --panel: #fff;
  --border: #e0e7ff;
  --text: #1e293b;
  --muted: #64748b;
}

body {
  background: var(--background);
  color: var(--text);
  font-family: 'Inter', 'Arial', sans-serif;
  margin: 0;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 32px 16px;
}

h1 {
  text-align: center;
  color: var(--primary);
  margin-bottom: 32px;
  letter-spacing: 1px;
  font-size: 2.2rem;
  font-weight: 700;
}

.panel {
  background: var(--panel);
  border-radius: 12px;
  box-shadow: 0 2px 12px rgba(37,99,235,0.07);
  border: 1px solid var(--border);
  padding: 24px;
  margin-bottom: 24px;
}

.section h2 {
  font-size: 1.3rem;
  color: var(--primary);
  margin-bottom: 12px;
  font-weight: 600;
}

input[type="text"], input[type="number"], textarea {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  background: #f8fafc;
  font-size: 1rem;
  margin-bottom: 12px;
  transition: border 0.2s, box-shadow 0.2s;
}

input[type="text"]:focus, input[type="number"]:focus, textarea:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 2px #2563eb33;
  background: #fff;
}

textarea {
  resize: vertical;
  min-height: 110px;
}

button {
  padding: 12px 20px;
  border-radius: 8px;
  font-size: 15px;
  font-weight: 600;
  background: var(--primary);
  color: #fff;
  border: none;
  box-shadow: 0 2px 6px rgba(37,99,235,0.08);
  transition: background 0.2s, transform 0.1s;
  cursor: pointer;
  margin-bottom: 8px;
}

button:hover {
  background: #1d4ed8;
  transform: translateY(-2px) scale(1.03);
}

button:active {
  background: #1e40af;
  transform: translateY(1px) scale(0.97);
}

.btn-success {
  background: var(--accent);
}
.btn-success:hover {
  background: #059669;
}
.btn-danger {
  background: var(--danger);
}
.btn-danger:hover {
  background: #dc2626;
}
.btn-secondary {
  background: var(--muted);
}
.btn-secondary:hover {
  background: var(--primary);
}

.dataset-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #f1f5fe;
  border-radius: 8px;
  margin-bottom: 10px;
  border: 1px solid #e0e7ff;
}

.color-box {
  width: 22px;
  height: 22px;
  border-radius: 6px;
  border: 1.5px solid #e0e7ff;
}

.dataset-name {
  flex: 1;
  font-size: 15px;
  color: var(--primary);
  font-weight: 500;
}

.icon-btn {
  width: 34px;
  height: 34px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  color: var(--primary);
  border-radius: 7px;
  font-size: 1.2rem;
  transition: background 0.18s;
  border: none;
}

.icon-btn:hover {
  background: #e0e7ff;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--primary);
  font-size: 1rem;
}

canvas {
  width: 100%;
  height: auto;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: #fff;
}

.stats {
  margin-top: 24px;
  padding: 18px;
  background: #f1f5fe;
  border-radius: 10px;
  border: 1px solid #e0e7ff;
}

.stat-item {
  margin-bottom: 10px;
  padding: 12px;
  background: var(--panel);
  border-radius: 8px;
  border: 1px solid #e0e7ff;
  font-size: 0.98rem;
}

.threshold-group {
  display: flex;
  gap: 12px;
}

.threshold-group input {
  flex: 1;
}

.toggle-btn {
  width: auto;
  padding: 10px 18px;
  font-size: 1rem;
}

.toggle-btn.active {
  background: var(--danger);
}

@media (max-width: 768px) {
  .grid { grid-template-columns: 1fr; }
  .container { padding: 16px 4px; }
  .panel { padding: 14px; }
}

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
<div class="container">
<h1>ヒストグラム生成ツール</h1>
<div class="grid">
<div>
<!-- データ入力 -->
<div class="panel section">
<h2>データ入力</h2>
<input type="text" id="datasetName" placeholder="データセット名" class="mb-2">
<textarea id="inputData" placeholder="数値データ（スペース、カンマ、改行区切り）" class="mb-2"></textarea>
<button class="btn-primary" onclick="addDataset()">➕ データセット追加</button>
</div>

<!-- ファイル読み込み -->

<div class="panel section">
<h2>エクセルファイル読み込み</h2>
<input type="file" id="fileInput" accept=".xlsx,.xls" style="display:none" onchange="handleFile(event)">
<button class="btn-success" onclick="document.getElementById('fileInput').click()">📁 ファイル選択</button>
</div>

<!-- 設定 -->

<div class="panel section">
<h2>ヒストグラム設定</h2>
<div class="mb-4">
<label class="text-sm">ビン幅</label>
<input type="number" id="binWidth" value="1" step="any" onchange="draw()">
<div class="text-xs">任意の正の数値を入力（例: 0.1, 1, 10）</div>
</div>
<div class="mb-4">
<label class="text-sm">シグマライン</label>
<div class="checkbox-group">
<label class="checkbox-label">
<input type="checkbox" id="sigma1" onchange="draw()"> 1σライン
</label>
<label class="checkbox-label">
<input type="checkbox" id="sigma2" onchange="draw()"> 2σライン
</label>
<label class="checkbox-label">
<input type="checkbox" id="sigma3" onchange="draw()"> 3σライン
</label>
</div>
</div>
<div class="mb-4">
<label class="text-sm">閾値</label>
<div class="threshold-group mb-2">
<input type="number" id="thresholdInput" placeholder="閾値を入力" step="any">
<button class="btn-primary" style="width:auto;padding:8px 16px" onclick="addThreshold()">追加</button>
</div>
<div id="thresholdList"></div>
</div>
</div>

<!-- データセット管理 -->

<div class="panel section">
<h2>データセット管理</h2>
<div id="datasetList"></div>
</div>
</div>

<div>
<!-- ヒストグラム -->
<div class="panel">
<h2>ヒストグラム</h2>
<canvas id="canvas" width="800" height="500"></canvas>
<div id="stats" class="stats" style="display:none"></div>
</div>
</div>
</div>

<!-- エクスポート -->

<div class="panel section" style="margin:20px auto 0;max-width:1200px">
<h2>エクスポート</h2>
<div style="display:flex;gap:20px;justify-content:center">
<button class="btn-secondary" style="width:300px" onclick="exportCSV()">💾 CSV出力</button>
<button class="btn-secondary" style="width:300px" onclick="exportImage()">🖼️ 画像出力</button>
</div>
</div>
</div>
</div>

<script>
let datasets = [];
let thresholds = [];

function round(n, d=12) {
  return Math.round(n * Math.pow(10, d)) / Math.pow(10, d);
}

function formatNum(n, bw) {
  if (bw >= 10) return n.toString();
  if (bw >= 1) return n.toFixed(1);
  if (bw >= 0.1) return n.toFixed(1);
  if (bw >= 0.01) return n.toFixed(2);
  if (bw >= 0.001) return n.toFixed(3);
  return n.toFixed(4);
}

function calcStats(data) {
  const n = data.length;
  const mean = data.reduce((s, v) => s + v, 0) / n;
  const variance = data.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n;
  return { mean: round(mean), stdDev: round(Math.sqrt(variance)) };
}

function generateHist(data, bw) {
  if (!data.length) return { bins: [], max: 0 };
  
  const min = Math.min(...data);
  const max = Math.max(...data);
  const minBin = round(Math.floor(min / bw) * bw);
  const maxBin = round(Math.ceil(max / bw) * bw);
  
  const bins = [];
  let curr = minBin;
  while (curr <= maxBin + bw / 2) {
    bins.push({ x: round(curr), count: 0 });
    curr = round(curr + bw);
  }
  
  data.forEach(v => {
    const idx = Math.round((v - minBin) / bw);
    if (idx >= 0 && idx < bins.length) bins[idx].count++;
  });
  
  return { bins, max: Math.max(...bins.map(b => b.count)) };
}

function addDataset() {
  const name = document.getElementById('datasetName').value.trim();
  const input = document.getElementById('inputData').value.trim();
  
  if (!name || !input) return;
  
  const values = input.split(/[\s,\n]+/)
    .map(v => parseFloat(v))
    .filter(v => !isNaN(v));
  
  if (!values.length) return;
  
  datasets.push({
    id: Date.now(),
    name,
    data: values,
    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
    visible: true
  });
  
  document.getElementById('datasetName').value = '';
  document.getElementById('inputData').value = '';
  
  updateDatasetList();
  draw();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const wb = XLSX.read(e.target.result, { type: 'binary' });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      
      const values = [];
      json.forEach(row => {
        row.forEach(cell => {
          const n = parseFloat(cell);
          if (!isNaN(n)) values.push(n);
        });
      });
      
      if (!values.length) {
        alert('数値データが見つかりませんでした');
        return;
      }
      
      datasets.push({
        id: Date.now(),
        name: file.name.replace(/\.[^/.]+$/, ''),
        data: values,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`,
        visible: true
      });
      
      updateDatasetList();
      draw();
    } catch (err) {
      alert('ファイル読み込みエラー: ' + err.message);
    }
  };
  reader.readAsBinaryString(file);
  e.target.value = '';
}

function toggleVisibility(id) {
  const ds = datasets.find(d => d.id === id);
  if (ds) {
    ds.visible = !ds.visible;
    updateDatasetList();
    draw();
  }
}

function removeDataset(id) {
  datasets = datasets.filter(d => d.id !== id);
  updateDatasetList();
  draw();
}

function updateDatasetList() {
  const list = document.getElementById('datasetList');
  list.innerHTML = datasets.map(d => `
    <div class="dataset-item">
      <div class="color-box" style="background:${d.color}"></div>
      <span class="dataset-name">${d.name} (${d.data.length}点)</span>
      <button class="icon-btn" onclick="toggleVisibility(${d.id})">${d.visible ? '👁️' : '🚫'}</button>
      <button class="icon-btn" onclick="removeDataset(${d.id})">🗑️</button>
    </div>
  `).join('');
}

function toggleThreshold() {
  showThreshold = !showThreshold;
  document.getElementById('thresholdToggle').classList.toggle('active', showThreshold);
  document.getElementById('thresholdToggle').classList.toggle('btn-danger', showThreshold);
  draw();
}

function draw() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // 背景を明るい色で塗る
  const gradient = ctx.createLinearGradient(0, 0, w, h);
  gradient.addColorStop(0, '#fafbfd');
  gradient.addColorStop(1, '#f0f4ff');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);
  
  const visible = datasets.filter(d => d.visible);
  if (!visible.length) {
    document.getElementById('stats').style.display = 'none';
    return;
  }
  
  const bw = parseFloat(document.getElementById('binWidth').value) || 1;
  const allData = visible.flatMap(d => d.data);
  
  if (!allData.length) return;
  
  const { bins: allBins } = generateHist(allData, bw);
  let maxCount = 0;
  
  const histData = visible.map(d => {
    const { bins, max } = generateHist(d.data, bw);
    maxCount = Math.max(maxCount, max);
    return { ...d, bins };
  });
  
  const margin = { top: 40, right: 40, bottom: 60, left: 60 };
  const cw = w - margin.left - margin.right;
  const ch = h - margin.top - margin.bottom;
  
  if (!allBins.length) return;
  
  const minX = Math.min(...allBins.map(b => b.x));
  const maxX = Math.max(...allBins.map(b => b.x)) + bw;
  
  // X軸とY軸の範囲を10%広げる
  const xRange = maxX - minX;
  const xPadding = xRange * 0.1;
  const adjustedMinX = minX - xPadding;
  const adjustedMaxX = maxX + xPadding;
  
  const yPadding = maxCount * 0.1;
  const adjustedMaxY = Math.ceil(maxCount + yPadding);
  
  const xScale = cw / (adjustedMaxX - adjustedMinX);
  const yScale = ch / adjustedMaxY;
  
  // グリッド
  ctx.strokeStyle = '#dbeafe';
  ctx.lineWidth = 1;
  
  const gridStepX = bw >= 1 ? bw : round(bw * Math.ceil(1 / bw));
  for (let x = round(Math.ceil(adjustedMinX / gridStepX) * gridStepX); x <= adjustedMaxX; x = round(x + gridStepX)) {
    const cx = margin.left + (x - adjustedMinX) * xScale;
    if (cx >= margin.left && cx <= margin.left + cw) {
      ctx.beginPath();
      ctx.moveTo(cx, margin.top);
      ctx.lineTo(cx, margin.top + ch);
      ctx.stroke();
    }
  }
  
  for (let y = 0; y <= adjustedMaxY; y++) {
    const cy = margin.top + ch - y * yScale;
    ctx.beginPath();
    ctx.moveTo(margin.left, cy);
    ctx.lineTo(margin.left + cw, cy);
    ctx.stroke();
  }
  
  // ヒストグラム（透過設定を強化）
  histData.forEach(d => {
    ctx.fillStyle = d.color + '60'; // 透過度を40%に
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 1.5;
    
    d.bins.forEach(b => {
      if (b.count > 0) {
        const x = margin.left + (b.x - adjustedMinX) * xScale;
        const y = margin.top + ch - b.count * yScale;
        const bw2 = bw * xScale;
        const bh = b.count * yScale;
        
        ctx.fillRect(x, y, bw2, bh);
        ctx.strokeRect(x, y, bw2, bh);
      }
    });
  });
  
  // シグマライン
  const labelPos = [];
  visible.forEach((d, di) => {
    const stats = calcStats(d.data);
    
    [1, 2, 3].forEach(sigma => {
      if (!document.getElementById(`sigma${sigma}`).checked) return;
      
      [stats.mean - sigma * stats.stdDev, stats.mean + sigma * stats.stdDev].forEach((x, i) => {
        if (x >= adjustedMinX && x <= adjustedMaxX) {
          const cx = margin.left + (x - adjustedMinX) * xScale;
          
          ctx.strokeStyle = d.color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cx, margin.top);
          ctx.lineTo(cx, margin.top + ch);
          ctx.stroke();
          ctx.setLineDash([]);
          
          let ly = margin.top + 15 + di * 40;
          labelPos.forEach(p => {
            if (Math.abs(cx - p.x) < 60 && Math.abs(ly - p.y) < 20) ly += 20;
          });
          
          const label = `${d.name} ${i === 0 ? '-' : '+'}${sigma}σ (${x.toFixed(3)})`;
          ctx.font = '11px Arial';
          const tw = ctx.measureText(label).width + 6;
          
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.fillRect(cx - tw/2, ly - 12, tw, 16);
          ctx.strokeStyle = d.color;
          ctx.lineWidth = 1;
          ctx.strokeRect(cx - tw/2, ly - 12, tw, 16);
          
          ctx.fillStyle = d.color;
          ctx.textAlign = 'center';
          ctx.fillText(label, cx, ly - 2);
          
          labelPos.push({ x: cx, y: ly });
        }
      });
    });
  });
  
  // 閾値（複数対応）
  thresholds.filter(t => t.visible).forEach(threshold => {
    const t = threshold.value;
    if (t >= adjustedMinX && t <= adjustedMaxX) {
      const cx = margin.left + (t - adjustedMinX) * xScale;
      
      ctx.strokeStyle = threshold.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, margin.top);
      ctx.lineTo(cx, margin.top + ch);
      ctx.stroke();
      
      let ly = margin.top + 15;
      labelPos.forEach(p => {
        if (Math.abs(cx - p.x) < 80 && Math.abs(ly - p.y) < 20) ly += 20;
      });
      
      const label = `閾値: ${formatNum(t, bw)}`;
      ctx.font = '11px Arial';
      const tw = ctx.measureText(label).width + 6;
      
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(cx - tw/2, ly - 12, tw, 16);
      ctx.strokeStyle = threshold.color;
      ctx.lineWidth = 1;
      ctx.strokeRect(cx - tw/2, ly - 12, tw, 16);
      
      ctx.fillStyle = threshold.color;
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, ly - 2);
      
      labelPos.push({ x: cx, y: ly });
    }
  });
  
  // 軸
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + ch);
  ctx.lineTo(margin.left + cw, margin.top + ch);
  ctx.stroke();
  
  // ラベル
  ctx.fillStyle = '#000';
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  
  const labelStep = round(bw * Math.max(1, Math.ceil(50 / (bw * xScale))));
  for (let x = round(Math.ceil(minX / labelStep) * labelStep); x <= maxX; x = round(x + labelStep)) {
    const cx = margin.left + (x - adjustedMinX) * xScale;
    if (cx >= margin.left && cx <= margin.left + cw) {
      ctx.fillText(formatNum(x, bw), cx, margin.top + ch + 20);
    }
  }
  
  ctx.textAlign = 'right';
  for (let y = 0; y <= adjustedMaxY; y += Math.ceil(adjustedMaxY / 10)) {
    const cy = margin.top + ch - y * yScale;
    ctx.fillText(y.toString(), margin.left - 10, cy + 4);
  }
  
  // 凡例
  ctx.textAlign = 'left';
  visible.forEach((d, i) => {
    const ly = margin.top + i * 20;
    ctx.fillStyle = d.color;
    ctx.fillRect(margin.left + cw + 10, ly - 10, 15, 15);
    ctx.fillStyle = '#000';
    ctx.fillText(d.name, margin.left + cw + 30, ly);
  });
  
  // 統計情報
  const statsDiv = document.getElementById('stats');
  if (visible.length > 0) {
    statsDiv.style.display = 'block';
    statsDiv.innerHTML = '<h3>統計情報</h3>' + 
      visible.map(d => {
        const s = calcStats(d.data);
        return `<div class="stat-item">
          <div style="display:flex;align-items:center;gap:8px">
            <div style="width:12px;height:12px;background:${d.color};border-radius:3px"></div>
            <strong>${d.name}</strong>
          </div>
          <div style="margin-left:20px;color:#666;font-size:13px">
            平均: ${s.mean.toFixed(3)}, 標準偏差: ${s.stdDev.toFixed(3)}, データ数: ${d.data.length}
          </div>
        </div>`;
      }).join('');
  }
}

function exportCSV() {
  if (!datasets.length) return;
  
  let csv = 'Dataset,Value\n';
  datasets.forEach(d => {
    d.data.forEach(v => {
      csv += `"${d.name}",${v}\n`;
    });
  });
  
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'histogram_data.csv';
  link.click();
}

function exportImage() {
  const canvas = document.getElementById('canvas');
  const link = document.createElement('a');
  link.download = 'histogram.png';
  link.href = canvas.toDataURL();
  link.click();
}
</script>

</body>
</html>
