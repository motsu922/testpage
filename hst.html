<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel ヒストグラム生成ツール</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/2.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/1.4.0/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:system-ui,sans-serif;background:#f5f5f5;color:#333;line-height:1.6}
        .container{max-width:1200px;margin:0 auto;padding:20px;background:#fff;min-height:100vh}
        h1{text-align:center;color:#2c3e50;margin-bottom:30px;font-size:2em}
        .section{margin-bottom:25px;padding:15px;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
        .section h2{color:#34495e;margin-bottom:15px;font-size:1.3em;border-bottom:2px solid #3498db;padding-bottom:8px}
        .upload-area{border:2px dashed #3498db;border-radius:8px;padding:30px;text-align:center;cursor:pointer;transition:all 0.3s;background:#f8f9fa}
        .upload-area:hover{border-color:#2980b9;background:#e3f2fd}
        .upload-area input{display:none}
        .direct-input{display:none;background:#f8f9fa;padding:15px;border-radius:8px;margin-top:15px}
        .input-group{margin-bottom:12px}
        .input-group label{display:block;margin-bottom:5px;font-weight:600;color:#2c3e50}
        .input-group input,.input-group textarea{width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px}
        .input-group textarea{resize:vertical;font-family:monospace}
        .btn{background:#3498db;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-size:14px;transition:background 0.3s;margin:5px}
        .btn:hover{background:#2980b9}
        .btn-success{background:#27ae60}.btn-success:hover{background:#219a52}
        .btn-danger{background:#e74c3c}.btn-danger:hover{background:#c0392b}
        .dataset-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:15px;margin-top:15px}
        .dataset-card{border:1px solid #ddd;border-radius:8px;padding:12px;background:white}
        .dataset-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
        .dataset-name{font-weight:600;font-size:15px}
        .range-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-bottom:15px}
        .range-option{border:2px solid #ddd;border-radius:8px;padding:12px;cursor:pointer;transition:all 0.3s}
        .range-option:hover{border-color:#3498db}
        .range-option.active{border-color:#3498db;background:#e3f2fd}
        .custom-range{display:none;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin-top:12px;padding:15px;background:#e3f2fd;border-radius:8px}
        .chart-container{position:relative;height:400px;margin:15px 0}
        .threshold-list{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
        .threshold-item{background:#fff5f5;border:1px solid #feb2b2;border-radius:4px;padding:4px 8px;display:flex;align-items:center;gap:5px}
        .slider-container{margin:12px 0}
        .slider-container input[type="range"]{width:100%;margin:8px 0}
        .info-panel{background:#f8f9fa;padding:12px;border-radius:8px;margin-top:12px;font-size:13px;color:#666}
        .empty-state{text-align:center;padding:40px 20px;color:#999}
        .checkbox-group{display:flex;flex-direction:column;gap:6px;margin-top:8px}
        .checkbox-item{display:flex;align-items:center;gap:6px}
        .spec-limits-info{background:#fff5f0;border:1px solid #ff6b35;border-radius:4px;padding:8px;margin-top:8px;font-size:12px;color:#d97706}
        .stats-info{font-size:11px;color:#666;margin-top:6px}
    </style>
</head>
<body>
    <!-- HTML部分は変更なし（同じ） -->
    <!-- ... -->
    
<script>
    // 他の変数や関数は変更なし
    
    function generateHistogramData() {
        const visibleDatasets = datasets.filter(d => d.visible);
        if (visibleDatasets.length === 0) return {data: [], range: {min: 0, max: 0}};

        const allData = visibleDatasets.flatMap(d => d.data);
        let min, max, binWidth;

        if (rangeMode === 'custom') {
            min = parseFloat(document.getElementById('customMin').value) || Math.min(...allData);
            max = parseFloat(document.getElementById('customMax').value) || Math.max(...allData);
            const customWidth = parseFloat(document.getElementById('customBinWidth').value);
            binWidth = customWidth > 0 ? customWidth : (max - min) / binCount;
        } else {
            min = Math.min(...allData);
            max = Math.max(...allData);
            // 最小値と最大値が同じ場合の処理を追加
            if (min === max) {
                if (min === 0) {
                    min = -1;
                    max = 1;
                } else {
                    const offset = Math.abs(min) * 0.1;
                    min -= offset;
                    max += offset;
                }
            }
            binWidth = (max - min) / binCount;
        }

        // 最小測定単位を適用
        binWidth = adjustBinWidthToMeasurementUnit(binWidth);

        // ビン数を再計算（小数単位に対応）
        const actualBinCount = Math.max(1, Math.ceil((max - min) / binWidth));
        
        // 最大値を調整してビン幅が均等になるように
        max = min + actualBinCount * binWidth;

        const bins = Array(actualBinCount).fill(0).map((_, i) => {
            const binStart = min + i * binWidth;
            const binEnd = min + (i + 1) * binWidth;
            const binCenter = binStart + binWidth / 2;
            const bin = {x: binCenter};
            
            visibleDatasets.forEach(dataset => {
                // 最後のビンは終端を含める
                bin[dataset.name] = dataset.data.filter(value => 
                    value >= binStart && (i === actualBinCount - 1 ? value <= binEnd : value < binEnd)
                ).length;
            });
            
            return bin;
        });

        return {data: bins, range: {min, max}, binWidth: binWidth};
    }

    function adjustBinWidthToMeasurementUnit(binWidth) {
        if (!measurementUnit.apply || measurementUnit.value === null) {
            return binWidth;
        }
        
        const unit = measurementUnit.value;
        if (unit <= 0) return binWidth;
        
        // ビン幅が測定単位の整数倍になるように調整
        const adjustedBinWidth = Math.max(unit, Math.ceil(binWidth / unit) * unit);
        
        return adjustedBinWidth;
    }

    function updateChart() {
        if (datasets.filter(d => d.visible).length === 0) return;

        const histogramData = generateHistogramData();
        const visibleDatasets = datasets.filter(d => d.visible);

        if (chart) chart.destroy();

        const ctx = document.getElementById('histogramChart').getContext('2d');
        
        // 小数点以下の表示桁数を決定
        const decimals = Math.max(0, -Math.floor(Math.log10(histogramData.binWidth))) + 2;
        
        chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: histogramData.data.map(d => d.x.toFixed(decimals)),
                datasets: visibleDatasets.map(dataset => ({
                    label: dataset.name,
                    data: histogramData.data.map(d => d[dataset.name]),
                    backgroundColor: dataset.color.replace('50%)', `${Math.round(opacity * 50)}%)`),
                    borderColor: dataset.color,
                    borderWidth: 0,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        min: histogramData.range.min,
                        max: histogramData.range.max,
                        title: {display: true, text: '値'},
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(decimals);
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {display: true, text: '出現回数'}
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: ctx => {
                                const index = ctx[0].dataIndex;
                                const binStart = histogramData.range.min + index * histogramData.binWidth;
                                const binEnd = binStart + histogramData.binWidth;
                                return `範囲: ${binStart.toFixed(decimals)} ～ ${binEnd.toFixed(decimals)}`;
                            },
                            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}回`
                        }
                    },
                    annotation: {
                        annotations: getChartAnnotations(visibleDatasets, histogramData)
                    }
                }
            },
            plugins: [window['chartjs-plugin-annotation']]
        });

        updateChartInfo(histogramData);
    }

    // 他の関数は変更なし
    // ...
</script>
</body>
</html>
