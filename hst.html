表のx軸範囲をもう少しひろげて

import React, { useState, useRef, useCallback } from ‘react’;
import { Download, Upload, Plus, Trash2, Eye, EyeOff } from ‘lucide-react’;
import * as XLSX from ‘xlsx’;

const HistogramGenerator = () => {
const [datasets, setDatasets] = useState([]);
const [inputData, setInputData] = useState(’’);
const [datasetName, setDatasetName] = useState(’’);
const [binWidth, setBinWidth] = useState(1);
const [showSigmaLines, setShowSigmaLines] = useState({ sigma1: false, sigma2: false, sigma3: false });
const [thresholdValue, setThresholdValue] = useState(’’);
const [showThreshold, setShowThreshold] = useState(false);
const fileInputRef = useRef(null);
const canvasRef = useRef(null);

// 浮動小数点誤差を避けるための丸め処理（精度を高める）
const roundToDecimal = (num, decimals = 12) => {
return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
};

// 数値を適切な桁数で表示するためのフォーマット関数
const formatNumber = (num, binWidth) => {
// 自動的に適切な桁数を決定
if (binWidth >= 10) {
return num.toString();
} else if (binWidth >= 1) {
return num.toFixed(1);
} else if (binWidth >= 0.1) {
return num.toFixed(1);
} else if (binWidth >= 0.01) {
return num.toFixed(2);
} else if (binWidth >= 0.001) {
return num.toFixed(3);
} else {
return num.toFixed(4);
}
};

// 統計計算
const calculateStats = (data) => {
const n = data.length;
const mean = data.reduce((sum, val) => sum + val, 0) / n;
const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
const stdDev = Math.sqrt(variance);
return { mean: roundToDecimal(mean), stdDev: roundToDecimal(stdDev) };
};

// ヒストグラムデータの生成（改良版）
const generateHistogramData = (data, binWidth) => {
if (data.length === 0) return { bins: [], max: 0 };

```
const min = Math.min(...data);
const max = Math.max(...data);

// ビンの範囲を計算（浮動小数点誤差を考慮）
const minBin = roundToDecimal(Math.floor(min / binWidth) * binWidth);
const maxBin = roundToDecimal(Math.ceil(max / binWidth) * binWidth);

const bins = [];
let currentBin = minBin;
while (currentBin <= maxBin + binWidth / 2) { // 小さな余裕を持たせる
  bins.push({ x: roundToDecimal(currentBin), count: 0 });
  currentBin = roundToDecimal(currentBin + binWidth);
}

// データをビンに分類（改良版）
data.forEach(value => {
  const binIndex = Math.round((value - minBin) / binWidth);
  if (binIndex >= 0 && binIndex < bins.length) {
    bins[binIndex].count++;
  }
});

const maxCount = Math.max(...bins.map(bin => bin.count));
return { bins, max: maxCount };
```

};

// データセット追加
const addDataset = () => {
if (!inputData.trim() || !datasetName.trim()) return;

```
const values = inputData.split(/[\s,\n]+/)
  .map(val => val.trim())
  .filter(val => val !== '')
  .map(val => parseFloat(val))
  .filter(val => !isNaN(val));

if (values.length === 0) return;

const newDataset = {
  id: Date.now(),
  name: datasetName,
  data: values,
  color: `hsl(${Math.random() * 360}, 70%, 50%)`,
  visible: true
};

setDatasets([...datasets, newDataset]);
setInputData('');
setDatasetName('');
```

};

// エクセルファイル読み込み
const handleFileUpload = async (event) => {
const file = event.target.files[0];
if (!file) return;

```
try {
  const data = await file.arrayBuffer();
  const workbook = XLSX.read(data);
  const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
  const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
  
  // 数値データのみを抽出
  const values = [];
  jsonData.forEach(row => {
    row.forEach(cell => {
      const num = parseFloat(cell);
      if (!isNaN(num)) {
        values.push(num);
      }
    });
  });
  
  if (values.length === 0) {
    alert('数値データが見つかりませんでした');
    return;
  }
  
  const newDataset = {
    id: Date.now(),
    name: file.name.replace(/\.[^/.]+$/, ''),
    data: values,
    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
    visible: true
  };
  
  setDatasets([...datasets, newDataset]);
} catch (error) {
  alert('ファイルの読み込みに失敗しました: ' + error.message);
}

event.target.value = '';
```

};

// データセット削除
const removeDataset = (id) => {
setDatasets(datasets.filter(dataset => dataset.id !== id));
};

// データセット表示切り替え
const toggleDatasetVisibility = (id) => {
setDatasets(datasets.map(dataset =>
dataset.id === id ? { …dataset, visible: !dataset.visible } : dataset
));
};

// CSV出力
const exportToCSV = () => {
if (datasets.length === 0) return;

```
let csvContent = 'Dataset,Value\n';
datasets.forEach(dataset => {
  dataset.data.forEach(value => {
    csvContent += `"${dataset.name}",${value}\n`;
  });
});

const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
const link = document.createElement('a');
const url = URL.createObjectURL(blob);
link.setAttribute('href', url);
link.setAttribute('download', 'histogram_data.csv');
link.click();
URL.revokeObjectURL(url);
```

};

// 画像出力
const exportToImage = () => {
if (!canvasRef.current) return;

```
const link = document.createElement('a');
link.download = 'histogram.png';
link.href = canvasRef.current.toDataURL();
link.click();
```

};

// ヒストグラム描画
const drawHistogram = useCallback(() => {
const canvas = canvasRef.current;
if (!canvas) return;

```
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

// キャンバスクリア
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, width, height);

const visibleDatasets = datasets.filter(dataset => dataset.visible);
if (visibleDatasets.length === 0) return;

// 全データから範囲と最大カウントを計算
let allData = [];
visibleDatasets.forEach(dataset => {
  allData = allData.concat(dataset.data);
});

if (allData.length === 0) return;

const { bins: allBins } = generateHistogramData(allData, binWidth);
let maxCount = 0;

const histogramDatasets = visibleDatasets.map(dataset => {
  const { bins, max } = generateHistogramData(dataset.data, binWidth);
  maxCount = Math.max(maxCount, max);
  return { ...dataset, bins };
});

// 描画領域設定
const margin = { top: 40, right: 40, bottom: 60, left: 60 };
const chartWidth = width - margin.left - margin.right;
const chartHeight = height - margin.top - margin.bottom;

if (allBins.length === 0) return;

const dataMinX = Math.min(...allBins.map(bin => bin.x));
const dataMaxX = Math.max(...allBins.map(bin => bin.x)) + binWidth;
const dataRange = dataMaxX - dataMinX;

// X軸範囲を拡張（データ範囲の30%ずつ両端に追加）
const extension = dataRange * 0.3;
const minX = dataMinX - extension;
const maxX = dataMaxX + extension;
const xScale = chartWidth / (maxX - minX);
const yScale = chartHeight / Math.ceil(maxCount);

// グリッド描画（改良版）
ctx.strokeStyle = '#e0e0e0';
ctx.lineWidth = 1;

// 縦線（X軸グリッド）- より細かい制御
const gridStepX = binWidth >= 1 ? binWidth : 
                 binWidth >= 0.1 ? roundToDecimal(binWidth * Math.ceil(1 / binWidth)) :
                 roundToDecimal(binWidth * Math.ceil(10 / binWidth));

for (let x = roundToDecimal(Math.ceil(minX / gridStepX) * gridStepX); x <= maxX; x = roundToDecimal(x + gridStepX)) {
  const canvasX = margin.left + (x - minX) * xScale;
  if (canvasX >= margin.left && canvasX <= margin.left + chartWidth) {
    ctx.beginPath();
    ctx.moveTo(canvasX, margin.top);
    ctx.lineTo(canvasX, margin.top + chartHeight);
    ctx.stroke();
  }
}

// 横線（Y軸グリッド）- 整数のみ
for (let y = 0; y <= Math.ceil(maxCount); y++) {
  const canvasY = margin.top + chartHeight - y * yScale;
  ctx.beginPath();
  ctx.moveTo(margin.left, canvasY);
  ctx.lineTo(margin.left + chartWidth, canvasY);
  ctx.stroke();
}

// ヒストグラム描画
histogramDatasets.forEach((dataset, datasetIndex) => {
  ctx.fillStyle = dataset.color + '80'; // 透明度を追加
  ctx.strokeStyle = dataset.color;
  ctx.lineWidth = 1;
  
  dataset.bins.forEach(bin => {
    if (bin.count > 0) {
      const x = margin.left + (bin.x - minX) * xScale;
      const y = margin.top + chartHeight - bin.count * yScale;
      const barWidth = binWidth * xScale;
      const barHeight = bin.count * yScale;
      
      ctx.fillRect(x, y, barWidth, barHeight);
      ctx.strokeRect(x, y, barWidth, barHeight);
    }
  });
});

// ラベル位置管理（重複防止）
const labelPositions = [];
const labelHeight = 15;
const minLabelGap = 5;

// シグマライン描画とラベル配置
visibleDatasets.forEach((dataset, datasetIndex) => {
  const stats = calculateStats(dataset.data);
  
  Object.entries(showSigmaLines).forEach(([key, show]) => {
    if (!show) return;
    
    const sigma = parseInt(key.replace('sigma', ''));
    const lines = [
      { x: stats.mean - sigma * stats.stdDev, label: `-${sigma}σ` },
      { x: stats.mean + sigma * stats.stdDev, label: `+${sigma}σ` }
    ];
    
    ctx.strokeStyle = dataset.color;
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    
    lines.forEach(({ x: lineX, label }) => {
      if (lineX >= minX && lineX <= maxX) {
        const canvasX = margin.left + (lineX - minX) * xScale;
        
        // ライン描画
        ctx.beginPath();
        ctx.moveTo(canvasX, margin.top);
        ctx.lineTo(canvasX, margin.top + chartHeight);
        ctx.stroke();
        
        // ラベルの位置を決定（重複回避）
        let labelY = margin.top + 15 + datasetIndex * 40;
        
        // 既存のラベルと重複しないよう調整
        let adjusted = true;
        while (adjusted) {
          adjusted = false;
          for (const pos of labelPositions) {
            if (Math.abs(canvasX - pos.x) < 60 && Math.abs(labelY - pos.y) < labelHeight + minLabelGap) {
              labelY += labelHeight + minLabelGap;
              adjusted = true;
              break;
            }
          }
        }
        
        // ラベル描画（背景付き）
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        const labelText = `${dataset.name} ${label}`;
        const textWidth = ctx.measureText(labelText).width + 6;
        ctx.fillRect(canvasX - textWidth/2, labelY - 12, textWidth, 16);
        
        ctx.strokeStyle = dataset.color;
        ctx.lineWidth = 1;
        ctx.strokeRect(canvasX - textWidth/2, labelY - 12, textWidth, 16);
        
        ctx.fillStyle = dataset.color;
        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(labelText, canvasX, labelY - 2);
        
        // 位置を記録
        labelPositions.push({ x: canvasX, y: labelY });
        
        ctx.setLineDash([5, 5]);
      }
    });
    
    ctx.setLineDash([]);
  });
});

// 閾値ライン描画とラベル
if (showThreshold && thresholdValue) {
  const threshold = parseFloat(thresholdValue);
  if (!isNaN(threshold) && threshold >= minX && threshold <= maxX) {
    const canvasX = margin.left + (threshold - minX) * xScale;
    
    // ライン描画
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(canvasX, margin.top);
    ctx.lineTo(canvasX, margin.top + chartHeight);
    ctx.stroke();
    
    // ラベルの位置を決定（重複回避）
    let labelY = margin.top + 15;
    let adjusted = true;
    while (adjusted) {
      adjusted = false;
      for (const pos of labelPositions) {
        if (Math.abs(canvasX - pos.x) < 60 && Math.abs(labelY - pos.y) < labelHeight + minLabelGap) {
          labelY += labelHeight + minLabelGap;
          adjusted = true;
          break;
        }
      }
    }
    
    // ラベル描画（背景付き）
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    const labelText = `閾値: ${formatNumber(threshold, binWidth)}`;
    const textWidth = ctx.measureText(labelText).width + 6;
    ctx.fillRect(canvasX - textWidth/2, labelY - 12, textWidth, 16);
    
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 1;
    ctx.strokeRect(canvasX - textWidth/2, labelY - 12, textWidth, 16);
    
    ctx.fillStyle = '#ff0000';
    ctx.font = '11px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(labelText, canvasX, labelY - 2);
  }
}

// 軸描画
ctx.strokeStyle = '#000';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(margin.left, margin.top);
ctx.lineTo(margin.left, margin.top + chartHeight);
ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
ctx.stroke();

// X軸ラベル（改良版）
ctx.fillStyle = '#000';
ctx.font = '12px Arial';
ctx.textAlign = 'center';

// ラベル間の最小間隔を計算（ビン幅に応じて調整）
const labelMinWidth = 50; // ラベル間の最小間隔（ピクセル）
const labelStepMultiplier = Math.max(1, Math.ceil(labelMinWidth / (binWidth * xScale)));
const labelStep = roundToDecimal(binWidth * labelStepMultiplier);

for (let x = roundToDecimal(Math.ceil(minX / labelStep) * labelStep); x <= maxX; x = roundToDecimal(x + labelStep)) {
  const canvasX = margin.left + (x - minX) * xScale;
  if (canvasX >= margin.left && canvasX <= margin.left + chartWidth) {
    ctx.fillText(formatNumber(x, binWidth), canvasX, margin.top + chartHeight + 20);
  }
}

// Y軸ラベル（整数のみ）
ctx.textAlign = 'right';
for (let y = 0; y <= Math.ceil(maxCount); y++) {
  const canvasY = margin.top + chartHeight - y * yScale;
  ctx.fillText(y.toString(), margin.left - 10, canvasY + 4);
}

// 凡例
ctx.textAlign = 'left';
visibleDatasets.forEach((dataset, index) => {
  const legendY = margin.top + index * 20;
  ctx.fillStyle = dataset.color;
  ctx.fillRect(margin.left + chartWidth + 10, legendY - 10, 15, 15);
  ctx.fillStyle = '#000';
  ctx.fillText(dataset.name, margin.left + chartWidth + 30, legendY);
});
```

}, [datasets, binWidth, showSigmaLines, thresholdValue, showThreshold]);

React.useEffect(() => {
drawHistogram();
}, [drawHistogram]);

return (

<div className="p-6 max-w-7xl mx-auto bg-white">
<h1 className="text-3xl font-bold mb-6 text-center text-gray-800">ヒストグラム生成ツール</h1>

```
  <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
    {/* 左側：データ入力・設定 */}
    <div className="space-y-6">
      {/* データ入力 */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">データ入力</h2>
        <input
          type="text"
          placeholder="データセット名"
          value={datasetName}
          onChange={(e) => setDatasetName(e.target.value)}
          className="w-full p-2 border rounded mb-2"
        />
        <textarea
          placeholder="数値データ（スペース、カンマ、改行区切り）"
          value={inputData}
          onChange={(e) => setInputData(e.target.value)}
          className="w-full p-2 border rounded h-32 mb-2"
        />
        <button
          onClick={addDataset}
          className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600 flex items-center justify-center gap-2"
        >
          <Plus className="w-4 h-4" />
          データセット追加
        </button>
      </div>

      {/* ファイル読み込み */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">エクセルファイル読み込み</h2>
        <input
          type="file"
          ref={fileInputRef}
          onChange={handleFileUpload}
          accept=".xlsx,.xls"
          className="hidden"
        />
        <button
          onClick={() => fileInputRef.current?.click()}
          className="w-full bg-green-500 text-white p-2 rounded hover:bg-green-600 flex items-center justify-center gap-2"
        >
          <Upload className="w-4 h-4" />
          エクセルファイル選択
        </button>
      </div>

      {/* 設定 */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">ヒストグラム設定</h2>
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">ビン幅</label>
          <input
            type="number"
            value={binWidth}
            onChange={(e) => {
              const value = parseFloat(e.target.value);
              if (!isNaN(value) && value > 0) {
                setBinWidth(value);
              }
            }}
            step="any"
            placeholder="例: 0.1, 1, 2.5"
            className="w-full p-2 border rounded"
          />
          <div className="text-xs text-gray-500 mt-1">
            任意の正の数値を入力できます（例: 0.001, 0.1, 1, 10）
          </div>
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium mb-2">シグマライン</label>
          {[1, 2, 3].map(sigma => (
            <label key={sigma} className="flex items-center mb-1">
              <input
                type="checkbox"
                checked={showSigmaLines[`sigma${sigma}`]}
                onChange={(e) => setShowSigmaLines({
                  ...showSigmaLines,
                  [`sigma${sigma}`]: e.target.checked
                })}
                className="mr-2"
              />
              {sigma}σライン
            </label>
          ))}
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium mb-1">閾値</label>
          <div className="flex gap-2">
            <input
              type="number"
              value={thresholdValue}
              onChange={(e) => setThresholdValue(e.target.value)}
              placeholder="閾値"
              step="any"
              className="flex-1 p-2 border rounded"
            />
            <button
              onClick={() => setShowThreshold(!showThreshold)}
              className={`px-3 py-2 rounded ${showThreshold ? 'bg-red-500 text-white' : 'bg-gray-200'}`}
            >
              表示
            </button>
          </div>
        </div>
      </div>

      {/* データセット管理 */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">データセット管理</h2>
        {datasets.map(dataset => (
          <div key={dataset.id} className="flex items-center gap-2 mb-2 p-2 bg-white rounded">
            <div
              className="w-4 h-4 rounded"
              style={{ backgroundColor: dataset.color }}
            />
            <span className="flex-1 text-sm">{dataset.name} ({dataset.data.length}点)</span>
            <button
              onClick={() => toggleDatasetVisibility(dataset.id)}
              className="p-1 hover:bg-gray-100 rounded"
            >
              {dataset.visible ? <Eye className="w-4 h-4" /> : <EyeOff className="w-4 h-4" />}
            </button>
            <button
              onClick={() => removeDataset(dataset.id)}
              className="p-1 hover:bg-gray-100 rounded text-red-500"
            >
              <Trash2 className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>

      {/* エクスポート */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">エクスポート</h2>
        <div className="space-y-2">
          <button
            onClick={exportToCSV}
            disabled={datasets.length === 0}
            className="w-full bg-purple-500 text-white p-2 rounded hover:bg-purple-600 disabled:bg-gray-300 flex items-center justify-center gap-2"
          >
            <Download className="w-4 h-4" />
            CSV出力
          </button>
          <button
            onClick={exportToImage}
            disabled={datasets.length === 0}
            className="w-full bg-orange-500 text-white p-2 rounded hover:bg-orange-600 disabled:bg-gray-300 flex items-center justify-center gap-2"
          >
            <Download className="w-4 h-4" />
            画像出力
          </button>
        </div>
      </div>
    </div>

    {/* 右側：ヒストグラム表示 */}
    <div className="lg:col-span-2">
      <div className="bg-gray-50 p-4 rounded-lg">
        <h2 className="text-lg font-semibold mb-3">ヒストグラム</h2>
        <canvas
          ref={canvasRef}
          width={800}
          height={500}
          className="border bg-white w-full max-w-full h-auto"
        />
        
        {/* 統計情報 */}
        {datasets.filter(d => d.visible).length > 0 && (
          <div className="mt-4 space-y-2">
            <h3 className="font-medium">統計情報</h3>
            {datasets.filter(d => d.visible).map(dataset => {
              const stats = calculateStats(dataset.data);
              return (
                <div key={dataset.id} className="text-sm p-2 bg-white rounded">
                  <div className="flex items-center gap-2 mb-1">
                    <div
                      className="w-3 h-3 rounded"
                      style={{ backgroundColor: dataset.color }}
                    />
                    <span className="font-medium">{dataset.name}</span>
                  </div>
                  <div className="ml-5 text-gray-600">
                    平均: {stats.mean.toFixed(3)}, 標準偏差: {stats.stdDev.toFixed(3)}, データ数: {dataset.data.length}
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  </div>
</div>
```

);
};

export default HistogramGenerator;
