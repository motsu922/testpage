yè»¸ã¯æ•´æ•°å›ºå®šã§

<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ç”Ÿæˆãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/2.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/1.4.0/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:system-ui,sans-serif;background:#f5f5f5;color:#333;line-height:1.6}
        .container{max-width:1200px;margin:0 auto;padding:20px;background:#fff;min-height:100vh}
        h1{text-align:center;color:#2c3e50;margin-bottom:30px;font-size:2em}
        .section{margin-bottom:25px;padding:15px;background:#fff;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
        .section h2{color:#34495e;margin-bottom:15px;font-size:1.3em;border-bottom:2px solid #3498db;padding-bottom:8px}
        .upload-area{border:2px dashed #3498db;border-radius:8px;padding:30px;text-align:center;cursor:pointer;transition:all 0.3s;background:#f8f9fa}
        .upload-area:hover{border-color:#2980b9;background:#e3f2fd}
        .upload-area input{display:none}
        .direct-input{display:none;background:#f8f9fa;padding:15px;border-radius:8px;margin-top:15px}
        .input-group{margin-bottom:12px}
        .input-group label{display:block;margin-bottom:5px;font-weight:600;color:#2c3e50}
        .input-group input,.input-group textarea{width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px}
        .input-group textarea{resize:vertical;font-family:monospace}
        .btn{background:#3498db;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;font-size:14px;transition:background 0.3s;margin:5px}
        .btn:hover{background:#2980b9}
        .btn-success{background:#27ae60}.btn-success:hover{background:#219a52}
        .btn-danger{background:#e74c3c}.btn-danger:hover{background:#c0392b}
        .dataset-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:15px;margin-top:15px}
        .dataset-card{border:1px solid #ddd;border-radius:8px;padding:12px;background:white}
        .dataset-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
        .dataset-name{font-weight:600;font-size:15px}
        .range-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-bottom:15px}
        .range-option{border:2px solid #ddd;border-radius:8px;padding:12px;cursor:pointer;transition:all 0.3s}
        .range-option:hover{border-color:#3498db}
        .range-option.active{border-color:#3498db;background:#e3f2fd}
        .custom-range{display:none;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin-top:12px;padding:15px;background:#e3f2fd;border-radius:8px}
        .chart-container{position:relative;height:400px;margin:15px 0}
        .threshold-list{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
        .threshold-item{background:#fff5f5;border:1px solid #feb2b2;border-radius:4px;padding:4px 8px;display:flex;align-items:center;gap:5px}
        .slider-container{margin:12px 0}
        .slider-container input[type="range"]{width:100%;margin:8px 0}
        .info-panel{background:#f8f9fa;padding:12px;border-radius:8px;margin-top:12px;font-size:13px;color:#666}
        .empty-state{text-align:center;padding:40px 20px;color:#999}
        .checkbox-group{display:flex;flex-direction:column;gap:6px;margin-top:8px}
        .checkbox-item{display:flex;align-items:center;gap:6px}
        .spec-limits-info{background:#fff5f0;border:1px solid #ff6b35;border-radius:4px;padding:8px;margin-top:8px;font-size:12px;color:#d97706}
        .stats-info{font-size:11px;color:#666;margin-top:6px}
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“Š Excel ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ç”Ÿæˆãƒ„ãƒ¼ãƒ«</h1>

```
    <div class="section">
        <h2>ğŸ“ ãƒ‡ãƒ¼ã‚¿å…¥åŠ›</h2>
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>ğŸ“‚ Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</p>
            <input type="file" id="fileInput" accept=".xlsx,.xls" multiple>
        </div>
        <button class="btn btn-success" onclick="toggleDirectInput()">âœï¸ ç›´æ¥å…¥åŠ›</button>
        
        <div id="directInput" class="direct-input">
            <div class="input-group">
                <label>ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå</label>
                <input type="text" id="datasetName" placeholder="ä¾‹: ãƒ‡ãƒ¼ã‚¿1">
            </div>
            <div class="input-group">
                <label>æ•°å€¤ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚«ãƒ³ãƒã€ã‚¹ãƒšãƒ¼ã‚¹ã€æ”¹è¡ŒåŒºåˆ‡ã‚Šï¼‰</label>
                <textarea id="dataValues" rows="3" placeholder="1, 2, 3, 4, 5"></textarea>
            </div>
            <button class="btn" onclick="addDirectData()">â• è¿½åŠ </button>
            <button class="btn" onclick="clearDirectInput()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
        </div>
    </div>
    
    <div id="datasetSection" class="section" style="display:none;">
        <h2>ğŸ“‹ ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ</h2>
        <div id="datasetList" class="dataset-grid"></div>
    </div>
    
    <div id="settingsSection" class="section" style="display:none;">
        <h2>âš™ï¸ è¨­å®š</h2>
        
        <div class="range-options">
            <div class="range-option active" onclick="setRangeMode('auto')">
                <h4>ğŸ“ˆ è‡ªå‹•ç¯„å›²</h4><p>æœ€å°å€¤ã€œæœ€å¤§å€¤</p>
            </div>
            <div class="range-option" onclick="setRangeMode('custom')">
                <h4>ğŸ›ï¸ ã‚«ã‚¹ã‚¿ãƒ </h4><p>æ‰‹å‹•æŒ‡å®š</p>
            </div>
        </div>
        
        <div id="customRange" class="custom-range">
            <div class="input-group">
                <label>æœ€å°å€¤</label>
                <input type="number" id="customMin" step="0.1">
            </div>
            <div class="input-group">
                <label>æœ€å¤§å€¤</label>
                <input type="number" id="customMax" step="0.1">
            </div>
            <div class="input-group">
                <label>ãƒ“ãƒ³å¹…</label>
                <input type="number" id="customBinWidth" step="0.1" min="0.01">
            </div>
            <div><button class="btn" onclick="setDataRange()">è‡ªå‹•è¨­å®š</button></div>
        </div>
        
        <div class="slider-container">
            <label>ãƒ“ãƒ³æ•°: <span id="binCountValue">20</span></label>
            <input type="range" id="binCount" min="5" max="100" value="20" oninput="updateBinCount()">
        </div>
        
        <div class="slider-container">
            <label>é€æ˜åº¦: <span id="opacityValue">80%</span></label>
            <input type="range" id="opacity" min="10" max="100" value="80" oninput="updateOpacity()">
        </div>
    </div>
    
    <div id="thresholdSection" class="section" style="display:none;">
        <h2>ğŸ“ é–¾å€¤ãƒ»è¦æ ¼é™ç•Œ</h2>
        
        <div style="margin-bottom:20px;">
            <h3 style="font-size:1.1em;margin-bottom:10px;color:#2c3e50;">ğŸ“ è¦æ ¼ä¸Šä¸‹é™</h3>
            <div style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;margin-bottom:10px;">
                <input type="number" id="specLower" placeholder="ä¸‹é™å€¤" style="padding:6px;border:1px solid #ddd;border-radius:4px;">
                <input type="number" id="specUpper" placeholder="ä¸Šé™å€¤" style="padding:6px;border:1px solid #ddd;border-radius:4px;">
                <button class="btn" onclick="setSpecLimits()">è¨­å®š</button>
            </div>
            <div style="display:flex;gap:10px;align-items:center;margin-bottom:10px;">
                <label style="display:flex;align-items:center;gap:5px;font-size:13px;">
                    <input type="checkbox" id="showSpecLimits" onchange="updateSpecLimitsVisibility()">
                    è¦æ ¼é™ç•Œã‚’è¡¨ç¤º
                </label>
                <button class="btn btn-danger" onclick="clearSpecLimits()" style="padding:4px 8px;font-size:12px;">ã‚¯ãƒªã‚¢</button>
            </div>
            <div id="specLimitsInfo" style="font-size:12px;color:#666;"></div>
        </div>
        
        <div>
            <h3 style="font-size:1.1em;margin-bottom:10px;color:#2c3e50;">ğŸ“Œ ã‚«ã‚¹ã‚¿ãƒ é–¾å€¤</h3>
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <input type="number" id="newThreshold" placeholder="é–¾å€¤" style="flex:1;padding:6px;border:1px solid #ddd;border-radius:4px;">
                <button class="btn" onclick="addThreshold()">â•</button>
            </div>
            <div id="thresholdList" class="threshold-list"></div>
        </div>
    </div>
    
    <div id="chartSection" class="section" style="display:none;">
        <h2>ğŸ“Š ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </h2>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <div style="display:flex;gap:8px;">
                <button class="btn" onclick="copyChartToClipboard()" title="ã‚°ãƒ©ãƒ•ã‚’ç”»åƒã¨ã—ã¦ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼">
                    ğŸ“‹ ã‚°ãƒ©ãƒ•ã‚’ã‚³ãƒ”ãƒ¼
                </button>
                <button class="btn" onclick="downloadChart()" title="ã‚°ãƒ©ãƒ•ã‚’ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">
                    ğŸ’¾ ç”»åƒä¿å­˜
                </button>
                <button class="btn" onclick="exportHistogramCSV()" title="ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’CSVãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦å‡ºåŠ›">
                    ğŸ“Š CSVå‡ºåŠ›
                </button>
            </div>
            <div id="copyStatus" style="font-size:12px;color:#666;"></div>
        </div>
        <div class="chart-container">
            <canvas id="histogramChart"></canvas>
        </div>
        <div id="chartInfo" class="info-panel"></div>
    </div>
    
    <div id="emptyState" class="empty-state">
        <h3>ğŸ“Š ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</h3>
        <p>Excelãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ç›´æ¥å…¥åŠ›ã§ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ </p>
    </div>
</div>

<script>
    let datasets=[], thresholds=[], chart=null, rangeMode='auto', binCount=20, opacity=0.8;
    let specLimits = {lower: null, upper: null, show: false};

    document.getElementById('fileInput').addEventListener('change', handleFileUpload);

    async function handleFileUpload(event) {
        const files = Array.from(event.target.files);
        for (const file of files) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer);
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header:1});
                
                const numericData = [];
                for (let row of jsonData) {
                    for (let cell of row) {
                        if (typeof cell === 'number' && !isNaN(cell)) {
                            numericData.push(cell);
                        }
                    }
                }
                
                if (numericData.length > 0) {
                    addDataset(file.name.replace(/\.(xlsx|xls)$/i, ''), numericData);
                }
            } catch (error) {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ' + file.name);
            }
        }
        event.target.value = '';
    }

    function toggleDirectInput() {
        const el = document.getElementById('directInput');
        el.style.display = el.style.display === 'none' ? 'block' : 'none';
    }

    function addDirectData() {
        const name = document.getElementById('datasetName').value.trim();
        const values = document.getElementById('dataValues').value.trim();
        
        if (!name || !values) {
            alert('åå‰ã¨æ•°å€¤ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
        }

        const numbers = values.split(/[,\s\n]+/).map(str => parseFloat(str.trim())).filter(num => !isNaN(num));
        if (numbers.length === 0) {
            alert('æœ‰åŠ¹ãªæ•°å€¤ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }

        addDataset(name, numbers);
        clearDirectInput();
        toggleDirectInput();
    }

    function clearDirectInput() {
        document.getElementById('datasetName').value = '';
        document.getElementById('dataValues').value = '';
    }

    function addDataset(name, data) {
        datasets.push({
            id: Date.now() + Math.random(),
            name: name,
            data: data,
            color: `hsl(${Math.random() * 360}, 70%, 50%)`,
            visible: true,
            sigmaSettings: {show1: false, show2: false, show3: false}
        });
        updateUI();
    }

    function removeDataset(id) {
        datasets = datasets.filter(d => d.id !== id);
        updateUI();
    }

    function toggleDatasetVisibility(id) {
        const dataset = datasets.find(d => d.id === id);
        if (dataset) {
            dataset.visible = !dataset.visible;
            updateChart();
        }
    }

    function toggleSigma(id, sigma) {
        const dataset = datasets.find(d => d.id === id);
        if (dataset) {
            dataset.sigmaSettings[`show${sigma}`] = !dataset.sigmaSettings[`show${sigma}`];
            updateChart();
        }
    }

    function calculateStats(data) {
        if (data.length === 0) return {mean: 0, stdDev: 0};
        const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
        const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / Math.max(data.length - 1, 1);
        return {mean, stdDev: Math.sqrt(variance)};
    }

    function setRangeMode(mode) {
        rangeMode = mode;
        document.querySelectorAll('.range-option').forEach(option => option.classList.remove('active'));
        event.target.closest('.range-option').classList.add('active');
        document.getElementById('customRange').style.display = mode === 'custom' ? 'grid' : 'none';
        updateChart();
    }

    function setDataRange() {
        const visibleData = datasets.filter(d => d.visible).flatMap(d => d.data);
        if (visibleData.length > 0) {
            document.getElementById('customMin').value = Math.min(...visibleData);
            document.getElementById('customMax').value = Math.max(...visibleData);
            updateChart();
        }
    }

    function updateBinCount() {
        binCount = parseInt(document.getElementById('binCount').value);
        document.getElementById('binCountValue').textContent = binCount;
        updateChart();
    }

    function updateOpacity() {
        opacity = parseInt(document.getElementById('opacity').value) / 100;
        document.getElementById('opacityValue').textContent = document.getElementById('opacity').value + '%';
        updateChart();
    }

    function addThreshold() {
        const value = parseFloat(document.getElementById('newThreshold').value);
        if (!isNaN(value)) {
            thresholds.push({id: Date.now(), value: value});
            document.getElementById('newThreshold').value = '';
            updateThresholdList();
            updateChart();
        }
    }

    function removeThreshold(id) {
        thresholds = thresholds.filter(t => t.id !== id);
        updateThresholdList();
        updateChart();
    }

    function updateThresholdList() {
        document.getElementById('thresholdList').innerHTML = thresholds.map(t => 
            `<div class="threshold-item"><span>${t.value}</span><button onclick="removeThreshold(${t.id})" style="background:none;border:none;color:#e74c3c;cursor:pointer;">âœ•</button></div>`
        ).join('');
    }

    function setSpecLimits() {
        const lower = parseFloat(document.getElementById('specLower').value);
        const upper = parseFloat(document.getElementById('specUpper').value);
        
        if (isNaN(lower) && isNaN(upper)) {
            alert('ä¸Šé™å€¤ã¾ãŸã¯ä¸‹é™å€¤ã®å°‘ãªãã¨ã‚‚ä¸€æ–¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
        }
        
        if (!isNaN(lower) && !isNaN(upper) && lower >= upper) {
            alert('ä¸‹é™å€¤ã¯ä¸Šé™å€¤ã‚ˆã‚Šå°ã•ã„å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
        }
        
        specLimits.lower = isNaN(lower) ? null : lower;
        specLimits.upper = isNaN(upper) ? null : upper;
        specLimits.show = true;
        document.getElementById('showSpecLimits').checked = true;
        
        updateSpecLimitsInfo();
        updateChart();
    }

    function clearSpecLimits() {
        specLimits = {lower: null, upper: null, show: false};
        document.getElementById('specLower').value = '';
        document.getElementById('specUpper').value = '';
        document.getElementById('showSpecLimits').checked = false;
        updateSpecLimitsInfo();
        updateChart();
    }

    function updateSpecLimitsVisibility() {
        specLimits.show = document.getElementById('showSpecLimits').checked;
        updateChart();
    }

    function updateSpecLimitsInfo() {
        const info = document.getElementById('specLimitsInfo');
        if (specLimits.lower !== null || specLimits.upper !== null) {
            const lowerText = specLimits.lower !== null ? `ä¸‹é™: ${specLimits.lower}` : '';
            const upperText = specLimits.upper !== null ? `ä¸Šé™: ${specLimits.upper}` : '';
            const separator = (lowerText && upperText) ? ', ' : '';
            info.textContent = `è¨­å®šæ¸ˆã¿è¦æ ¼é™ç•Œ: ${lowerText}${separator}${upperText}`;
        } else {
            info.textContent = '';
        }
    }

    function generateHistogramData() {
        const visibleDatasets = datasets.filter(d => d.visible);
        if (visibleDatasets.length === 0) return {data: [], range: {min: 0, max: 0}};

        const allData = visibleDatasets.flatMap(d => d.data);
        let min, max, binWidth;

        if (rangeMode === 'custom') {
            min = parseFloat(document.getElementById('customMin').value) || Math.min(...allData);
            max = parseFloat(document.getElementById('customMax').value) || Math.max(...allData);
            const customWidth = parseFloat(document.getElementById('customBinWidth').value);
            binWidth = customWidth > 0 ? customWidth : (max - min) / binCount;
        } else {
            min = Math.min(...allData);
            max = Math.max(...allData);
            binWidth = (max - min) / binCount;
        }

        const actualBinCount = rangeMode === 'custom' && document.getElementById('customBinWidth').value
            ? Math.ceil((max - min) / binWidth) : binCount;

        const bins = Array(actualBinCount).fill(0).map((_, i) => {
            const binStart = min + i * binWidth;
            const binEnd = min + (i + 1) * binWidth;
            const binCenter = binStart + binWidth / 2;
            const bin = {x: binCenter};
            
            visibleDatasets.forEach(dataset => {
                bin[dataset.name] = dataset.data.filter(value => value >= binStart && value < binEnd).length;
            });
            
            return bin;
        });

        return {data: bins, range: {min, max}};
    }

    function updateChart() {
        if (datasets.filter(d => d.visible).length === 0) return;

        const histogramData = generateHistogramData();
        const visibleDatasets = datasets.filter(d => d.visible);

        if (chart) chart.destroy();

        const ctx = document.getElementById('histogramChart').getContext('2d');
        
        // ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®æº–å‚™
        const annotations = {};
        
        // ã™ã¹ã¦ã®ãƒ©ã‚¤ãƒ³æƒ…å ±ã‚’åé›†ã—ã¦ã‚½ãƒ¼ãƒˆ
        const allLines = [];
        
        // è¦æ ¼ä¸Šä¸‹é™ç·š
        if (specLimits.show) {
            if (specLimits.lower !== null) {
                allLines.push({
                    value: specLimits.lower,
                    type: 'spec',
                    id: 'specLower',
                    label: `ä¸‹é™: ${specLimits.lower}`,
                    color: '#ff6b35'
                });
            }
            if (specLimits.upper !== null) {
                allLines.push({
                    value: specLimits.upper,
                    type: 'spec',
                    id: 'specUpper',
                    label: `ä¸Šé™: ${specLimits.upper}`,
                    color: '#ff6b35'
                });
            }
        }
        
        // é–¾å€¤ç·š
        thresholds.forEach((threshold, index) => {
            allLines.push({
                value: threshold.value,
                type: 'threshold',
                id: `threshold${index}`,
                label: `é–¾å€¤: ${threshold.value}`,
                color: '#dc2626'
            });
        });
        
        // ã‚·ã‚°ãƒãƒ©ã‚¤ãƒ³
        visibleDatasets.forEach((dataset, datasetIndex) => {
            const stats = calculateStats(dataset.data);
            [1, 2, 3].forEach(sigma => {
                if (dataset.sigmaSettings[`show${sigma}`]) {
                    const upperValue = stats.mean + sigma * stats.stdDev;
                    const lowerValue = stats.mean - sigma * stats.stdDev;
                    
                    allLines.push({
                        value: stats.mean,
                        type: 'sigma',
                        id: `mean_${datasetIndex}`,
                        label: 'å¹³å‡',
                        color: dataset.color
                    });
                    
                    allLines.push({
                        value: upperValue,
                        type: 'sigma',
                        id: `upper_${datasetIndex}_${sigma}`,
                        label: `+${sigma}Ïƒ`,
                        color: dataset.color
                    });
                    
                    allLines.push({
                        value: lowerValue,
                        type: 'sigma',
                        id: `lower_${datasetIndex}_${sigma}`,
                        label: `-${sigma}Ïƒ`,
                        color: dataset.color
                    });
                }
            });
        });
        
        // å€¤ã§ã‚½ãƒ¼ãƒˆã—ã¦é‡è¤‡ã‚’é™¤å»
        const uniqueLines = [];
        allLines.sort((a, b) => a.value - b.value).forEach(line => {
            const existing = uniqueLines.find(ul => Math.abs(ul.value - line.value) < 0.01);
            if (!existing) {
                uniqueLines.push(line);
            } else {
                // è¿‘ã„å€¤ã®å ´åˆã€ãƒ©ãƒ™ãƒ«ã‚’çµåˆ
                existing.label += ` / ${line.label}`;
                if (line.type === 'spec') existing.color = line.color; // è¦æ ¼é™ç•Œã‚’å„ªå…ˆ
            }
        });
        
        // ãƒ©ãƒ™ãƒ«ä½ç½®ã‚’æ±ºå®šï¼ˆäº¤äº’é…ç½®ï¼‰
        const labelPositions = ['start', 'end'];
        let positionIndex = 0;
        
        uniqueLines.forEach((line, index) => {
            // è¿‘æ¥ã™ã‚‹ãƒ©ã‚¤ãƒ³ã®ä½ç½®ã‚’äº¤äº’ã«é…ç½®
            const position = labelPositions[positionIndex];
            positionIndex = (positionIndex + 1) % labelPositions.length;
            
            if (line.type === 'spec') {
                annotations[line.id] = {
                    type: 'line',
                    xMin: line.value,
                    xMax: line.value,
                    borderColor: line.color,
                    borderWidth: 4,
                    borderDash: [10, 5],
                    label: {
                        enabled: true,
                        content: line.label,
                        position: position,
                        backgroundColor: line.color,
                        color: 'white',
                        yAdjust: index % 2 === 0 ? -10 : 10
                    }
                };
            } else if (line.type === 'threshold') {
                annotations[line.id] = {
                    type: 'line',
                    xMin: line.value,
                    xMax: line.value,
                    borderColor: line.color,
                    borderWidth: 3,
                    label: {
                        enabled: true,
                        content: line.label,
                        position: position,
                        backgroundColor: line.color,
                        color: 'white',
                        yAdjust: index % 2 === 0 ? -10 : 10
                    }
                };
            } else if (line.type === 'sigma') {
                annotations[line.id] = {
                    type: 'line',
                    xMin: line.value,
                    xMax: line.value,
                    borderColor: line.color,
                    borderWidth: line.label === 'å¹³å‡' ? 3 : 2,
                    borderDash: line.label === 'å¹³å‡' ? [] : [8, 4],
                    label: {
                        enabled: true,
                        content: line.label,
                        position: position,
                        backgroundColor: line.color,
                        color: 'white',
                        yAdjust: index % 2 === 0 ? -10 : 10
                    }
                };
            }
        });
        
        // ã‚·ã‚°ãƒãƒ©ã‚¤ãƒ³ï¼ˆã™ã§ã«allLinesã«è¿½åŠ æ¸ˆã¿ãªã®ã§å‰Šé™¤ï¼‰

        chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: histogramData.data.map(d => d.x.toFixed(3)),
                datasets: visibleDatasets.map(dataset => ({
                    label: dataset.name,
                    data: histogramData.data.map(d => d[dataset.name]),
                    backgroundColor: dataset.color.replace('50%)', `${Math.round(opacity * 50)}%)`),
                    borderColor: dataset.color,
                    borderWidth: 0,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                }))
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        min: histogramData.range.min,
                        max: histogramData.range.max,
                        title: {display: true, text: 'å€¤'}
                    },
                    y: {
                        beginAtZero: true,
                        title: {display: true, text: 'å‡ºç¾å›æ•°'}
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: ctx => `å€¤: ${parseFloat(ctx[0].label).toFixed(3)}`,
                            label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}å›`
                        }
                    },
                    annotation: {
                        annotations: annotations
                    }
                }
            },
            plugins: [window['chartjs-plugin-annotation']]
        });

        updateChartInfo(histogramData);
    }

    function updateChartInfo(histogramData) {
        const customWidth = document.getElementById('customBinWidth').value;
        const visibleDatasets = datasets.filter(d => d.visible);
        
        // è¦æ ¼å¤–ãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—
        let specAnalysis = '';
        if (specLimits.show && (specLimits.lower !== null || specLimits.upper !== null)) {
            const analysisResults = visibleDatasets.map(dataset => {
                const totalCount = dataset.data.length;
                let outOfSpecCount = 0;
                
                dataset.data.forEach(value => {
                    if (specLimits.lower !== null && value < specLimits.lower) outOfSpecCount++;
                    if (specLimits.upper !== null && value > specLimits.upper) outOfSpecCount++;
                });
                
                const outOfSpecRate = (outOfSpecCount / totalCount * 100).toFixed(2);
                return `${dataset.name}: ${outOfSpecCount}/${totalCount} (${outOfSpecRate}%)`;
            });
            
            specAnalysis = ` <strong>| è¦æ ¼å¤–:</strong> ${analysisResults.join(', ')}`;
        }
        
        document.getElementById('chartInfo').innerHTML = `
            <strong>ç¯„å›²:</strong> ${rangeMode === 'auto' ? 'ãƒ‡ãƒ¼ã‚¿å…¨ç¯„å›²' : 
                `${histogramData.range.min.toFixed(2)} ï½ ${histogramData.range.max.toFixed(2)}`}
            <strong> | è¨­å®š:</strong> ${customWidth ? `ãƒ“ãƒ³å¹…: ${customWidth}` : `ãƒ“ãƒ³æ•°: ${binCount}`}${specAnalysis}
        `;
    }

    function updateDatasetList() {
        const list = document.getElementById('datasetList');
        list.innerHTML = datasets.map(dataset => {
            const stats = calculateStats(dataset.data);
            return `
                <div class="dataset-card">
                    <div class="dataset-header">
                        <span class="dataset-name" style="color:${dataset.color}">${dataset.name}</span>
                        <div>
                            <button onclick="toggleDatasetVisibility(${dataset.id})" class="btn" style="padding:4px 8px;">${dataset.visible ? 'ğŸ‘ï¸' : 'ğŸ™ˆ'}</button>
                            <button onclick="removeDataset(${dataset.id})" class="btn btn-danger" style="padding:4px 8px;">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div style="font-size:13px;color:#666;margin-bottom:8px;">ãƒ‡ãƒ¼ã‚¿æ•°: ${dataset.data.length}</div>
                    <div class="checkbox-group">
                        <div style="font-size:13px;font-weight:600;margin-bottom:4px;">ã‚·ã‚°ãƒãƒ©ã‚¤ãƒ³:</div>
                        ${[1,2,3].map(sigma => {
                            const upper = stats.mean + sigma * stats.stdDev;
                            const lower = stats.mean - sigma * stats.stdDev;
                            return `<div class="checkbox-item">
                                <input type="checkbox" ${dataset.sigmaSettings[`show${sigma}`] ? 'checked' : ''} 
                                       onchange="toggleSigma(${dataset.id}, ${sigma})">
                                <span style="font-size:12px;">${sigma}Ïƒ (${lower.toFixed(2)} ï½ ${upper.toFixed(2)})</span>
                            </div>`;
                        }).join('')}
                        <div class="stats-info">å¹³å‡: ${stats.mean.toFixed(2)}, æ¨™æº–åå·®: ${stats.stdDev.toFixed(2)}</div>
                    </div>
                </div>
            `;
        }).join('');
    }

    function updateUI() {
        const hasData = datasets.length > 0;
        document.getElementById('emptyState').style.display = hasData ? 'none' : 'block';
        document.getElementById('datasetSection').style.display = hasData ? 'block' : 'none';
        document.getElementById('settingsSection').style.display = hasData ? 'block' : 'none';
        document.getElementById('thresholdSection').style.display = hasData ? 'block' : 'none';
        document.getElementById('chartSection').style.display = hasData ? 'block' : 'none';
        
        if (hasData) {
            updateDatasetList();
            updateChart();
        }
    }

    async function copyChartToClipboard() {
        if (!chart) {
            showCopyStatus('ã‚°ãƒ©ãƒ•ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
            return;
        }

        try {
            showCopyStatus('ã‚³ãƒ”ãƒ¼ä¸­...', 'info');
            
            // Canvasã‚’é«˜è§£åƒåº¦ã§å–å¾—
            const canvas = chart.canvas;
            const ctx = canvas.getContext('2d');
            
            // ä¸€æ™‚çš„ã«èƒŒæ™¯ã‚’ç™½ã«è¨­å®šã—ã¦ã‚¯ãƒªã‚¢ãªç”»åƒã‚’ç”Ÿæˆ
            const originalComposite = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = originalComposite;
            
            // Canvas ã‚’ Blob ã«å¤‰æ›
            const blob = await new Promise(resolve => {
                canvas.toBlob(resolve, 'image/png', 1.0);
            });
            
            // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«æ›¸ãè¾¼ã¿
            if (navigator.clipboard && window.ClipboardItem) {
                await navigator.clipboard.write([
                    new ClipboardItem({
                        'image/png': blob
                    })
                ]);
                showCopyStatus('âœ… ã‚°ãƒ©ãƒ•ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ', 'success');
            } else {
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ¼ã‚¿URLã‚’ç”Ÿæˆã—ã¦ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ã‚³ãƒ”ãƒ¼
                const dataUrl = canvas.toDataURL('image/png');
                await navigator.clipboard.writeText(dataUrl);
                showCopyStatus('âš ï¸ ãƒ‡ãƒ¼ã‚¿URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆç”»åƒã¨ã—ã¦è²¼ã‚Šä»˜ã‘ã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰', 'warning');
            }
            
            // ãƒãƒ£ãƒ¼ãƒˆã‚’å†æç”»ã—ã¦èƒŒæ™¯ã‚’ãƒªã‚»ãƒƒãƒˆ
            chart.update('none');
            
        } catch (error) {
            console.error('ã‚³ãƒ”ãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
            showCopyStatus('âŒ ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
        }
    }

    function downloadChart() {
        if (!chart) {
            showCopyStatus('ã‚°ãƒ©ãƒ•ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
            return;
        }

        try {
            showCopyStatus('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æº–å‚™ä¸­...', 'info');
            
            const canvas = chart.canvas;
            const ctx = canvas.getContext('2d');
            
            // ä¸€æ™‚çš„ã«èƒŒæ™¯ã‚’ç™½ã«è¨­å®š
            const originalComposite = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = originalComposite;
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã®ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
            const link = document.createElement('a');
            link.download = `histogram_${new Date().toISOString().slice(0,19).replace(/[T:]/g, '_')}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Ÿè¡Œ
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showCopyStatus('âœ… ã‚°ãƒ©ãƒ•ã‚’ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã—ã¾ã—ãŸ', 'success');
            
            // ãƒãƒ£ãƒ¼ãƒˆã‚’å†æç”»ã—ã¦èƒŒæ™¯ã‚’ãƒªã‚»ãƒƒãƒˆ
            chart.update('none');
            
        } catch (error) {
            console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
            showCopyStatus('âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
        }
    }

    function showCopyStatus(message, type) {
        const statusEl = document.getElementById('copyStatus');
        statusEl.textContent = message;
        
        // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
        statusEl.style.color = type === 'success' ? '#27ae60' : 
                             type === 'error' ? '#e74c3c' : 
                             type === 'warning' ? '#f39c12' : '#666';
        
        // 3ç§’å¾Œã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
        setTimeout(() => {
            statusEl.textContent = '';
        }, 3000);
    }

    function exportHistogramCSV() {
        const visibleDatasets = datasets.filter(d => d.visible);
        if (visibleDatasets.length === 0) {
            showCopyStatus('è¡¨ç¤ºå¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“', 'error');
            return;
        }

        try {
            showCopyStatus('CSVç”Ÿæˆä¸­...', 'info');
            
            const histogramData = generateHistogramData();
            if (histogramData.data.length === 0) {
                showCopyStatus('ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }

            // CSVãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ä½œæˆ
            const headers = ['ãƒ“ãƒ³ä¸­å¤®å€¤', 'ãƒ“ãƒ³ç¯„å›²é–‹å§‹', 'ãƒ“ãƒ³ç¯„å›²çµ‚äº†'];
            visibleDatasets.forEach(dataset => {
                headers.push(`${dataset.name}_å‡ºç¾å›æ•°`);
                headers.push(`${dataset.name}_ç›¸å¯¾é »åº¦(%)`);
            });

            // çµ±è¨ˆæƒ…å ±ã‚’è¿½åŠ 
            headers.push('åˆè¨ˆå‡ºç¾å›æ•°', 'å…¨ä½“ç›¸å¯¾é »åº¦(%)');

            // CSVãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
            const csvRows = [headers];
            
            // ãƒ“ãƒ³å¹…ã‚’è¨ˆç®—
            const binWidth = histogramData.data.length > 1 ? 
                histogramData.data[1].x - histogramData.data[0].x : 1;
            
            histogramData.data.forEach(bin => {
                const binStart = bin.x - binWidth / 2;
                const binEnd = bin.x + binWidth / 2;
                
                const row = [
                    bin.x.toFixed(4),
                    binStart.toFixed(4),
                    binEnd.toFixed(4)
                ];

                let totalCount = 0;
                
                // å„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®å‡ºç¾å›æ•°ã¨ç›¸å¯¾é »åº¦
                visibleDatasets.forEach(dataset => {
                    const count = bin[dataset.name] || 0;
                    const totalDataPoints = dataset.data.length;
                    const relativeFreq = totalDataPoints > 0 ? (count / totalDataPoints * 100) : 0;
                    
                    row.push(count);
                    row.push(relativeFreq.toFixed(2));
                    totalCount += count;
                });

                // å…¨ä½“ã®å‡ºç¾å›æ•°ã¨ç›¸å¯¾é »åº¦
                const allDataPoints = visibleDatasets.reduce((sum, ds) => sum + ds.data.length, 0);
                const totalRelativeFreq = allDataPoints > 0 ? (totalCount / allDataPoints * 100) : 0;
                
                row.push(totalCount);
                row.push(totalRelativeFreq.toFixed(2));
                
                csvRows.push(row);
            });

            // çµ±è¨ˆã‚µãƒãƒªãƒ¼ã‚’è¿½åŠ 
            csvRows.push([]); // ç©ºè¡Œ
            csvRows.push(['çµ±è¨ˆã‚µãƒãƒªãƒ¼']);
            csvRows.push(['ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå', 'ãƒ‡ãƒ¼ã‚¿æ•°', 'å¹³å‡', 'æ¨™æº–åå·®', 'æœ€å°å€¤', 'æœ€å¤§å€¤', 'è¦æ ¼å¤–æ•°', 'è¦æ ¼å¤–ç‡(%)']);
            
            visibleDatasets.forEach(dataset => {
                const stats = calculateStats(dataset.data);
                const min = Math.min(...dataset.data);
                const max = Math.max(...dataset.data);
                
                // è¦æ ¼å¤–ãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—
                let outOfSpecCount = 0;
                if (specLimits.show && (specLimits.lower !== null || specLimits.upper !== null)) {
                    dataset.data.forEach(value => {
                        if (specLimits.lower !== null && value < specLimits.lower) outOfSpecCount++;
                        if (specLimits.upper !== null && value > specLimits.upper) outOfSpecCount++;
                    });
                }
                const outOfSpecRate = dataset.data.length > 0 ? (outOfSpecCount / dataset.data.length * 100) : 0;
                
                csvRows.push([
                    dataset.name,
                    dataset.data.length,
                    stats.mean.toFixed(4),
                    stats.stdDev.toFixed(4),
                    min.toFixed(4),
                    max.toFixed(4),
                    outOfSpecCount,
                    outOfSpecRate.toFixed(2)
                ]);
            });

            // è¨­å®šæƒ…å ±ã‚’è¿½åŠ 
            csvRows.push([]); // ç©ºè¡Œ
            csvRows.push(['è¨­å®šæƒ…å ±']);
            csvRows.push(['é …ç›®', 'å€¤']);
            csvRows.push(['ç¯„å›²ãƒ¢ãƒ¼ãƒ‰', rangeMode === 'auto' ? 'è‡ªå‹•ç¯„å›²' : 'ã‚«ã‚¹ã‚¿ãƒ ç¯„å›²']);
            csvRows.push(['ãƒ“ãƒ³æ•°', binCount]);
            csvRows.push(['ãƒ‡ãƒ¼ã‚¿ç¯„å›²', `${histogramData.range.min.toFixed(4)} ï½ ${histogramData.range.max.toFixed(4)}`]);
            csvRows.push(['ãƒ“ãƒ³å¹…', binWidth.toFixed(4)]);
            
            if (specLimits.show && (specLimits.lower !== null || specLimits.upper !== null)) {
                csvRows.push(['è¦æ ¼ä¸‹é™', specLimits.lower !== null ? specLimits.lower : 'ãªã—']);
                csvRows.push(['è¦æ ¼ä¸Šé™', specLimits.upper !== null ? specLimits.upper : 'ãªã—']);
            }

            // CSVãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
            const csvContent = csvRows.map(row => 
                row.map(cell => 
                    typeof cell === 'string' && (cell.includes(',') || cell.includes('"') || cell.includes('\n')) 
                        ? `"${cell.replace(/"/g, '""')}"` 
                        : cell
                ).join(',')
            ).join('\n');

            // BOMä»˜ãUTF-8ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const bom = '\uFEFF';
            const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
            
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `histogram_data_${new Date().toISOString().slice(0,19).replace(/[T:]/g, '_')}.csv`);
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showCopyStatus('âœ… ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’CSVãƒ•ã‚¡ã‚¤ãƒ«ã§å‡ºåŠ›ã—ã¾ã—ãŸ', 'success');
            
        } catch (error) {
            console.error('CSVå‡ºåŠ›ã‚¨ãƒ©ãƒ¼:', error);
            showCopyStatus('âŒ CSVå‡ºåŠ›ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
        }
    }
</script>
```

</body>
</html>
