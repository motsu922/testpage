<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ヒストグラム生成ツール</title>
<style>
body{margin:0;font-family:Arial,sans-serif;background:#fafbfd}
.container{max-width:1200px;margin:0 auto;padding:20px}
h1{text-align:center;color:#1e40af;margin-bottom:30px}
.grid{display:grid;grid-template-columns:1fr 2fr;gap:20px}
.panel{background:white;border-radius:12px;padding:20px;box-shadow:0 2px 8px rgba(59,130,246,0.08);border:1px solid #e0e7ff}
.section{margin-bottom:20px}
.section h2{font-size:18px;margin-bottom:15px;color:#3730a3}
input[type="text"],input[type="number"],textarea{width:100%;padding:8px;border:1px solid #c7d2fe;border-radius:6px;box-sizing:border-box;background:#f9fafb}
input[type="text"]:focus,input[type="number"]:focus,textarea:focus{outline:none;border-color:#60a5fa;background:white}
textarea{resize:vertical;min-height:100px}
button{width:100%;padding:10px;border:none;border-radius:6px;cursor:pointer;font-weight:bold;transition:all 0.3s}
.btn-primary{background:#60a5fa;color:white}
.btn-primary:hover{background:#3b82f6;transform:translateY(-1px)}
.btn-success{background:#34d399;color:white}
.btn-success:hover{background:#10b981;transform:translateY(-1px)}
.btn-danger{background:#f87171;color:white}
.btn-danger:hover{background:#ef4444;transform:translateY(-1px)}
.btn-secondary{background:#93c5fd;color:white}
.btn-secondary:hover{background:#60a5fa;transform:translateY(-1px)}
.dataset-item{display:flex;align-items:center;gap:10px;padding:10px;background:#eff6ff;border-radius:6px;margin-bottom:8px;border:1px solid #dbeafe}
.color-box{width:20px;height:20px;border-radius:4px}
.dataset-name{flex:1;font-size:14px;color:#1e40af}
.icon-btn{width:30px;height:30px;padding:0;display:inline-flex;align-items:center;justify-content:center;background:transparent;color:#60a5fa}
.icon-btn:hover{background:#dbeafe;border-radius:4px}
.checkbox-group{display:flex;flex-direction:column;gap:8px}
.checkbox-label{display:flex;align-items:center;gap:8px;color:#3730a3}
canvas{width:100%;height:auto;border:1px solid #c7d2fe;border-radius:8px}
.stats{margin-top:20px;padding:15px;background:#eff6ff;border-radius:8px;border:1px solid #dbeafe}
.stat-item{margin-bottom:8px;padding:10px;background:white;border-radius:6px;border:1px solid #e0e7ff}
.threshold-group{display:flex;gap:10px}
.threshold-group input{flex:1}
.toggle-btn{width:auto;padding:8px 16px}
.toggle-btn.active{background:#f87171}
.mb-2{margin-bottom:8px}
.mb-4{margin-bottom:16px}
.text-sm{font-size:14px;color:#4c1d95}
.text-xs{font-size:12px;color:#6366f1}
@media(max-width:768px){.grid{grid-template-columns:1fr}}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
<div class="container">
<h1>ヒストグラム生成ツール</h1>
<div class="grid">
<div>
<!-- データ入力 -->
<div class="panel section">
<h2>データ入力</h2>
<input type="text" id="datasetName" placeholder="データセット名" class="mb-2">
<textarea id="inputData" placeholder="数値データ（スペース、カンマ、改行区切り）" class="mb-2"></textarea>
<button class="btn-primary" onclick="addDataset()">➕ データセット追加</button>
</div>

<!-- ファイル読み込み -->

<div class="panel section">
<h2>エクセルファイル読み込み</h2>
<input type="file" id="fileInput" accept=".xlsx,.xls" style="display:none" onchange="handleFile(event)">
<button class="btn-success" onclick="document.getElementById('fileInput').click()">📁 ファイル選択</button>
</div>

<!-- 設定 -->

<div class="panel section">
<h2>ヒストグラム設定</h2>
<div class="mb-4">
<label class="text-sm">ビン幅</label>
<input type="number" id="binWidth" value="1" step="any" onchange="draw()">
<div class="text-xs">任意の正の数値を入力（例: 0.1, 1, 10）</div>
</div>
<div class="mb-4">
<label class="text-sm">シグマライン</label>
<div class="checkbox-group">
<label class="checkbox-label">
<input type="checkbox" id="sigma1" onchange="draw()"> 1σライン
</label>
<label class="checkbox-label">
<input type="checkbox" id="sigma2" onchange="draw()"> 2σライン
</label>
<label class="checkbox-label">
<input type="checkbox" id="sigma3" onchange="draw()"> 3σライン
</label>
</div>
</div>
<div class="mb-4">
<label class="text-sm">閾値</label>
<div class="threshold-group">
<input type="number" id="threshold" placeholder="閾値" step="any" onchange="draw()">
<button id="thresholdToggle" class="toggle-btn btn-secondary" onclick="toggleThreshold()">表示</button>
</div>
</div>
</div>

<!-- データセット管理 -->

<div class="panel section">
<h2>データセット管理</h2>
<div id="datasetList"></div>
</div>
</div>

<div>
<!-- ヒストグラム -->
<div class="panel">
<h2>ヒストグラム</h2>
<canvas id="canvas" width="800" height="500"></canvas>
<div id="stats" class="stats" style="display:none"></div>
</div>
</div>
</div>

<!-- エクスポート -->

<div class="panel section" style="margin:20px auto 0;max-width:1200px">
<h2>エクスポート</h2>
<div style="display:flex;gap:20px;justify-content:center">
<button class="btn-secondary" style="width:300px" onclick="exportCSV()">💾 CSV出力</button>
<button class="btn-secondary" style="width:300px" onclick="exportImage()">🖼️ 画像出力</button>
</div>
</div>
</div>
</div>

<script>
let datasets = [];
let showThreshold = false;

function round(n, d=12) {
  return Math.round(n * Math.pow(10, d)) / Math.pow(10, d);
}

function formatNum(n, bw) {
  if (bw >= 10) return n.toString();
  if (bw >= 1) return n.toFixed(1);
  if (bw >= 0.1) return n.toFixed(1);
  if (bw >= 0.01) return n.toFixed(2);
  if (bw >= 0.001) return n.toFixed(3);
  return n.toFixed(4);
}

function calcStats(data) {
  const n = data.length;
  const mean = data.reduce((s, v) => s + v, 0) / n;
  const variance = data.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n;
  return { mean: round(mean), stdDev: round(Math.sqrt(variance)) };
}

function generateHist(data, bw) {
  if (!data.length) return { bins: [], max: 0 };
  
  const min = Math.min(...data);
  const max = Math.max(...data);
  const minBin = round(Math.floor(min / bw) * bw);
  const maxBin = round(Math.ceil(max / bw) * bw);
  
  const bins = [];
  let curr = minBin;
  while (curr <= maxBin + bw / 2) {
    bins.push({ x: round(curr), count: 0 });
    curr = round(curr + bw);
  }
  
  data.forEach(v => {
    const idx = Math.round((v - minBin) / bw);
    if (idx >= 0 && idx < bins.length) bins[idx].count++;
  });
  
  return { bins, max: Math.max(...bins.map(b => b.count)) };
}

function addDataset() {
  const name = document.getElementById('datasetName').value.trim();
  const input = document.getElementById('inputData').value.trim();
  
  if (!name || !input) return;
  
  const values = input.split(/[\s,\n]+/)
    .map(v => parseFloat(v))
    .filter(v => !isNaN(v));
  
  if (!values.length) return;
  
  datasets.push({
    id: Date.now(),
    name,
    data: values,
    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
    visible: true
  });
  
  document.getElementById('datasetName').value = '';
  document.getElementById('inputData').value = '';
  
  updateDatasetList();
  draw();
}

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const wb = XLSX.read(e.target.result, { type: 'binary' });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      
      const values = [];
      json.forEach(row => {
        row.forEach(cell => {
          const n = parseFloat(cell);
          if (!isNaN(n)) values.push(n);
        });
      });
      
      if (!values.length) {
        alert('数値データが見つかりませんでした');
        return;
      }
      
      datasets.push({
        id: Date.now(),
        name: file.name.replace(/\.[^/.]+$/, ''),
        data: values,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`,
        visible: true
      });
      
      updateDatasetList();
      draw();
    } catch (err) {
      alert('ファイル読み込みエラー: ' + err.message);
    }
  };
  reader.readAsBinaryString(file);
  e.target.value = '';
}

function toggleVisibility(id) {
  const ds = datasets.find(d => d.id === id);
  if (ds) {
    ds.visible = !ds.visible;
    updateDatasetList();
    draw();
  }
}

function removeDataset(id) {
  datasets = datasets.filter(d => d.id !== id);
  updateDatasetList();
  draw();
}

function updateDatasetList() {
  const list = document.getElementById('datasetList');
  list.innerHTML = datasets.map(d => `
    <div class="dataset-item">
      <div class="color-box" style="background:${d.color}"></div>
      <span class="dataset-name">${d.name} (${d.data.length}点)</span>
      <button class="icon-btn" onclick="toggleVisibility(${d.id})">${d.visible ? '👁️' : '🚫'}</button>
      <button class="icon-btn" onclick="removeDataset(${d.id})">🗑️</button>
    </div>
  `).join('');
}

function toggleThreshold() {
  showThreshold = !showThreshold;
  document.getElementById('thresholdToggle').classList.toggle('active', showThreshold);
  document.getElementById('thresholdToggle').classList.toggle('btn-danger', showThreshold);
  draw();
}

function draw() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // 背景を明るい色で塗る
  const gradient = ctx.createLinearGradient(0, 0, w, h);
  gradient.addColorStop(0, '#fafbfd');
  gradient.addColorStop(1, '#f0f4ff');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, w, h);
  
  const visible = datasets.filter(d => d.visible);
  if (!visible.length) {
    document.getElementById('stats').style.display = 'none';
    return;
  }
  
  const bw = parseFloat(document.getElementById('binWidth').value) || 1;
  const allData = visible.flatMap(d => d.data);
  
  if (!allData.length) return;
  
  const { bins: allBins } = generateHist(allData, bw);
  let maxCount = 0;
  
  const histData = visible.map(d => {
    const { bins, max } = generateHist(d.data, bw);
    maxCount = Math.max(maxCount, max);
    return { ...d, bins };
  });
  
  const margin = { top: 40, right: 40, bottom: 60, left: 60 };
  const cw = w - margin.left - margin.right;
  const ch = h - margin.top - margin.bottom;
  
  if (!allBins.length) return;
  
  const minX = Math.min(...allBins.map(b => b.x));
  const maxX = Math.max(...allBins.map(b => b.x)) + bw;
  
  // X軸とY軸の範囲を10%広げる
  const xRange = maxX - minX;
  const xPadding = xRange * 0.1;
  const adjustedMinX = minX - xPadding;
  const adjustedMaxX = maxX + xPadding;
  
  const yPadding = maxCount * 0.1;
  const adjustedMaxY = Math.ceil(maxCount + yPadding);
  
  const xScale = cw / (adjustedMaxX - adjustedMinX);
  const yScale = ch / adjustedMaxY;
  
  // グリッド
  ctx.strokeStyle = '#dbeafe';
  ctx.lineWidth = 1;
  
  const gridStepX = bw >= 1 ? bw : round(bw * Math.ceil(1 / bw));
  for (let x = round(Math.ceil(adjustedMinX / gridStepX) * gridStepX); x <= adjustedMaxX; x = round(x + gridStepX)) {
    const cx = margin.left + (x - adjustedMinX) * xScale;
    if (cx >= margin.left && cx <= margin.left + cw) {
      ctx.beginPath();
      ctx.moveTo(cx, margin.top);
      ctx.lineTo(cx, margin.top + ch);
      ctx.stroke();
    }
  }
  
  for (let y = 0; y <= adjustedMaxY; y++) {
    const cy = margin.top + ch - y * yScale;
    ctx.beginPath();
    ctx.moveTo(margin.left, cy);
    ctx.lineTo(margin.left + cw, cy);
    ctx.stroke();
  }
  
  // ヒストグラム
  histData.forEach(d => {
    ctx.fillStyle = d.color + '80';
    ctx.strokeStyle = d.color;
    ctx.lineWidth = 1;
    
    d.bins.forEach(b => {
      if (b.count > 0) {
        const x = margin.left + (b.x - adjustedMinX) * xScale;
        const y = margin.top + ch - b.count * yScale;
        const bw2 = bw * xScale;
        const bh = b.count * yScale;
        
        ctx.fillRect(x, y, bw2, bh);
        ctx.strokeRect(x, y, bw2, bh);
      }
    });
  });
  
  // シグマライン
  const labelPos = [];
  visible.forEach((d, di) => {
    const stats = calcStats(d.data);
    
    [1, 2, 3].forEach(sigma => {
      if (!document.getElementById(`sigma${sigma}`).checked) return;
      
      [stats.mean - sigma * stats.stdDev, stats.mean + sigma * stats.stdDev].forEach((x, i) => {
        if (x >= adjustedMinX && x <= adjustedMaxX) {
          const cx = margin.left + (x - adjustedMinX) * xScale;
          
          ctx.strokeStyle = d.color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(cx, margin.top);
          ctx.lineTo(cx, margin.top + ch);
          ctx.stroke();
          ctx.setLineDash([]);
          
          let ly = margin.top + 15 + di * 40;
          labelPos.forEach(p => {
            if (Math.abs(cx - p.x) < 60 && Math.abs(ly - p.y) < 20) ly += 20;
          });
          
          const label = `${d.name} ${i === 0 ? '-' : '+'}${sigma}σ`;
          ctx.font = '11px Arial';
          const tw = ctx.measureText(label).width + 6;
          
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.fillRect(cx - tw/2, ly - 12, tw, 16);
          ctx.strokeStyle = d.color;
          ctx.lineWidth = 1;
          ctx.strokeRect(cx - tw/2, ly - 12, tw, 16);
          
          ctx.fillStyle = d.color;
          ctx.textAlign = 'center';
          ctx.fillText(label, cx, ly - 2);
          
          labelPos.push({ x: cx, y: ly });
        }
      });
    });
  });
  
  // 閾値
  if (showThreshold) {
    const t = parseFloat(document.getElementById('threshold').value);
    if (!isNaN(t) && t >= adjustedMinX && t <= adjustedMaxX) {
      const cx = margin.left + (t - adjustedMinX) * xScale;
      
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, margin.top);
      ctx.lineTo(cx, margin.top + ch);
      ctx.stroke();
      
      let ly = margin.top + 15;
      labelPos.forEach(p => {
        if (Math.abs(cx - p.x) < 60 && Math.abs(ly - p.y) < 20) ly += 20;
      });
      
      const label = `閾値: ${formatNum(t, bw)}`;
      ctx.font = '11px Arial';
      const tw = ctx.measureText(label).width + 6;
      
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(cx - tw/2, ly - 12, tw, 16);
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 1;
      ctx.strokeRect(cx - tw/2, ly - 12, tw, 16);
      
      ctx.fillStyle = '#ff0000';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, ly - 2);
    }
  }
  
  // 軸
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + ch);
  ctx.lineTo(margin.left + cw, margin.top + ch);
  ctx.stroke();
  
  // ラベル
  ctx.fillStyle = '#000';
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  
  const labelStep = round(bw * Math.max(1, Math.ceil(50 / (bw * xScale))));
  for (let x = round(Math.ceil(minX / labelStep) * labelStep); x <= maxX; x = round(x + labelStep)) {
    const cx = margin.left + (x - adjustedMinX) * xScale;
    if (cx >= margin.left && cx <= margin.left + cw) {
      ctx.fillText(formatNum(x, bw), cx, margin.top + ch + 20);
    }
  }
  
  ctx.textAlign = 'right';
  for (let y = 0; y <= adjustedMaxY; y += Math.ceil(adjustedMaxY / 10)) {
    const cy = margin.top + ch - y * yScale;
    ctx.fillText(y.toString(), margin.left - 10, cy + 4);
  }
  
  // 凡例
  ctx.textAlign = 'left';
  visible.forEach((d, i) => {
    const ly = margin.top + i * 20;
    ctx.fillStyle = d.color;
    ctx.fillRect(margin.left + cw + 10, ly - 10, 15, 15);
    ctx.fillStyle = '#000';
    ctx.fillText(d.name, margin.left + cw + 30, ly);
  });
  
  // 統計情報
  const statsDiv = document.getElementById('stats');
  if (visible.length > 0) {
    statsDiv.style.display = 'block';
    statsDiv.innerHTML = '<h3>統計情報</h3>' + 
      visible.map(d => {
        const s = calcStats(d.data);
        return `<div class="stat-item">
          <div style="display:flex;align-items:center;gap:8px">
            <div style="width:12px;height:12px;background:${d.color};border-radius:3px"></div>
            <strong>${d.name}</strong>
          </div>
          <div style="margin-left:20px;color:#666;font-size:13px">
            平均: ${s.mean.toFixed(3)}, 標準偏差: ${s.stdDev.toFixed(3)}, データ数: ${d.data.length}
          </div>
        </div>`;
      }).join('');
  }
}

function exportCSV() {
  if (!datasets.length) return;
  
  let csv = 'Dataset,Value\n';
  datasets.forEach(d => {
    d.data.forEach(v => {
      csv += `"${d.name}",${v}\n`;
    });
  });
  
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'histogram_data.csv';
  link.click();
}

function exportImage() {
  const canvas = document.getElementById('canvas');
  const link = document.createElement('a');
  link.download = 'histogram.png';
  link.href = canvas.toDataURL();
  link.click();
}
</script>

</body>
</html>

