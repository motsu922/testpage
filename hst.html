import React, { useState, useCallback, useMemo } from ‘react’;
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine } from ‘recharts’;
import { Upload, Plus, Minus, Eye, EyeOff, Edit3 } from ‘lucide-react’;
import * as XLSX from ‘xlsx’;

const HistogramTool = () => {
const [datasets, setDatasets] = useState([]);
const [thresholds, setThresholds] = useState([]);
const [newThreshold, setNewThreshold] = useState(’’);
const [binCount, setBinCount] = useState(20);
const [sigmaSettings, setSigmaSettings] = useState({});
const [directInput, setDirectInput] = useState(’’);
const [datasetName, setDatasetName] = useState(’’);
const [showDirectInput, setShowDirectInput] = useState(false);
const [opacity, setOpacity] = useState(0.6);
const [rangeMode, setRangeMode] = useState(‘6sigma’); // ‘6sigma’, ‘custom’, ‘auto’
const [customMin, setCustomMin] = useState(’’);
const [customMax, setCustomMax] = useState(’’);
const [customBinWidth, setCustomBinWidth] = useState(’’);

// 直接入力データの追加
const addDirectInputData = () => {
if (!directInput.trim() || !datasetName.trim()) return;

```
const numbers = directInput
  .split(/[,\s\n]+/)
  .map(str => str.trim())
  .filter(str => str.length > 0)
  .map(str => parseFloat(str))
  .filter(num => !isNaN(num));

if (numbers.length === 0) {
  alert('有効な数値が見つかりません');
  return;
}

const newDataset = {
  id: Date.now() + Math.random(),
  name: datasetName,
  data: numbers,
  color: `hsl(${Math.random() * 360}, 70%, 50%)`,
  visible: true
};

setDatasets(prev => [...prev, newDataset]);
setSigmaSettings(prev => ({
  ...prev,
  [newDataset.id]: { show1: false, show2: false, show3: false }
}));

setDirectInput('');
setDatasetName('');
setShowDirectInput(false);
```

};

// ファイルアップロード処理
const handleFileUpload = useCallback(async (event) => {
const uploadedFiles = Array.from(event.target.files);

```
for (const file of uploadedFiles) {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
    
    const numericData = [];
    for (let row of jsonData) {
      for (let cell of row) {
        if (typeof cell === 'number' && !isNaN(cell)) {
          numericData.push(cell);
        }
      }
    }
    
    if (numericData.length > 0) {
      const newDataset = {
        id: Date.now() + Math.random(),
        name: file.name.replace('.xlsx', '').replace('.xls', ''),
        data: numericData,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`,
        visible: true
      };
      
      setDatasets(prev => [...prev, newDataset]);
      setSigmaSettings(prev => ({
        ...prev,
        [newDataset.id]: { show1: false, show2: false, show3: false }
      }));
    }
  } catch (error) {
    console.error('ファイル読み込みエラー:', error);
  }
}

event.target.value = '';
```

}, []);

// キリの良い数値を計算する関数
const getTickInterval = (min, max) => {
const range = max - min;
const roughInterval = range / 10; // 大体10個の目盛りを目安

```
// キリの良い数値の候補
const niceNumbers = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000, 2000, 2500, 5000, 10000];

// 最適なキリの良い数値を選択
let bestInterval = niceNumbers[niceNumbers.length - 1];
for (let nice of niceNumbers) {
  if (nice >= roughInterval) {
    bestInterval = nice;
    break;
  }
}

return bestInterval;
```

};

// キリの良い目盛り値を生成
const getTickValues = (min, max) => {
const interval = getTickInterval(min, max);
const startTick = Math.floor(min / interval) * interval;
const endTick = Math.ceil(max / interval) * interval;

```
const ticks = [];
for (let tick = startTick; tick <= endTick; tick += interval) {
  ticks.push(Math.round(tick * 1000000) / 1000000); // 小数点以下6桁で丸める
}

return ticks;
```

};
const calculateStats = useCallback((data) => {
const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (data.length - 1);
const stdDev = Math.sqrt(variance);
return { mean, stdDev };
}, []);

// ヒストグラムデータ生成
const histogramData = useMemo(() => {
if (datasets.length === 0) return { data: [], range: { min: 0, max: 0 } };

```
const visibleDatasets = datasets.filter(d => d.visible);
if (visibleDatasets.length === 0) return { data: [], range: { min: 0, max: 0 } };

const allData = visibleDatasets.flatMap(d => d.data);
let min, max, binWidth;

// 表示範囲の決定
if (rangeMode === '6sigma') {
  const overallMean = allData.reduce((sum, val) => sum + val, 0) / allData.length;
  const overallVariance = allData.reduce((sum, val) => sum + Math.pow(val - overallMean, 2), 0) / (allData.length - 1);
  const overallStdDev = Math.sqrt(overallVariance);
  min = overallMean - 6 * overallStdDev;
  max = overallMean + 6 * overallStdDev;
  binWidth = (max - min) / binCount;
} else if (rangeMode === 'custom') {
  min = parseFloat(customMin) || Math.min(...allData);
  max = parseFloat(customMax) || Math.max(...allData);
  if (customBinWidth) {
    binWidth = parseFloat(customBinWidth);
  } else {
    binWidth = (max - min) / binCount;
  }
} else { // auto
  min = Math.min(...allData);
  max = Math.max(...allData);
  binWidth = (max - min) / binCount;
}

// ビン数を計算（カスタム幅の場合）
const actualBinCount = customBinWidth && rangeMode === 'custom' 
  ? Math.ceil((max - min) / binWidth)
  : binCount;

// ビン範囲を作成
const binRanges = Array(actualBinCount).fill(0).map((_, i) => ({
  start: min + i * binWidth,
  end: min + (i + 1) * binWidth,
  center: min + (i + 0.5) * binWidth,
}));

// 各データセットのヒストグラムを計算
const combinedData = binRanges.map((bin) => {
  const point = { x: bin.center };
  
  visibleDatasets.forEach(dataset => {
    let count = 0;
    
    // 実際の出現値をそのままカウント
    dataset.data.forEach(value => {
      if (value >= bin.start && value < bin.end) {
        count++;
      }
    });
    
    point[dataset.name] = count;
  });
  
  return point;
});

return { data: combinedData, range: { min, max } };
```

}, [datasets, binCount, rangeMode, customMin, customMax, customBinWidth]);

// 閾値追加
const addThreshold = () => {
const value = parseFloat(newThreshold);
if (!isNaN(value)) {
setThresholds(prev => […prev, { id: Date.now(), value, label: `閾値 ${value}` }]);
setNewThreshold(’’);
}
};

// 閾値削除
const removeThreshold = (id) => {
setThresholds(prev => prev.filter(t => t.id !== id));
};

// データセット可視性切り替え
const toggleDatasetVisibility = (id) => {
setDatasets(prev => prev.map(d =>
d.id === id ? { …d, visible: !d.visible } : d
));
};

// データセット削除
const removeDataset = (id) => {
setDatasets(prev => prev.filter(d => d.id !== id));
setSigmaSettings(prev => {
const newSettings = { …prev };
delete newSettings[id];
return newSettings;
});
};

// シグマ設定切り替え
const toggleSigma = (datasetId, sigmaLevel) => {
setSigmaSettings(prev => ({
…prev,
[datasetId]: {
…prev[datasetId],
[`show${sigmaLevel}`]: !prev[datasetId][`show${sigmaLevel}`]
}
}));
};

// シグマライン生成
const getSigmaLines = () => {
const lines = [];
datasets.filter(d => d.visible).forEach(dataset => {
const stats = calculateStats(dataset.data);
const settings = sigmaSettings[dataset.id] || {};

```
  [1, 2, 3].forEach(sigma => {
    if (settings[`show${sigma}`]) {
      const upperValue = stats.mean + sigma * stats.stdDev;
      const lowerValue = stats.mean - sigma * stats.stdDev;
      
      lines.push(
        <ReferenceLine 
          key={`${dataset.id}-mean`}
          x={stats.mean}
          stroke={dataset.color}
          strokeWidth={3}
          label={{ value: `平均 (${dataset.name})`, position: 'top' }}
        />
      );
      
      lines.push(
        <ReferenceLine 
          key={`${dataset.id}-${sigma}sigma-upper`}
          x={upperValue}
          stroke={dataset.color}
          strokeDasharray="8 4"
          strokeWidth={2}
          label={{ 
            value: `+${sigma}σ (${upperValue.toFixed(2)})`, 
            position: 'topRight'
          }}
        />
      );
      
      lines.push(
        <ReferenceLine 
          key={`${dataset.id}-${sigma}sigma-lower`}
          x={lowerValue}
          stroke={dataset.color}
          strokeDasharray="8 4"
          strokeWidth={2}
          label={{ 
            value: `-${sigma}σ (${lowerValue.toFixed(2)})`, 
            position: 'topLeft'
          }}
        />
      );
    }
  });
});
return lines;
```

};

return (
<div className="p-6 max-w-7xl mx-auto bg-white">
<h1 className="text-3xl font-bold mb-6 text-gray-800">Excel ヒストグラム生成ツール</h1>

```
  {/* ファイルアップロード */}
  <div className="mb-6 p-4 border-2 border-dashed border-gray-300 rounded-lg">
    <div className="flex items-center justify-center">
      <label className="flex flex-col items-center cursor-pointer">
        <Upload className="w-8 h-8 text-gray-400 mb-2" />
        <span className="text-sm text-gray-600">Excelファイルをアップロード</span>
        <input
          type="file"
          accept=".xlsx,.xls"
          multiple
          onChange={handleFileUpload}
          className="hidden"
        />
      </label>
    </div>
  </div>

  {/* 直接入力セクション */}
  <div className="mb-6">
    <div className="flex items-center justify-between mb-3">
      <h2 className="text-xl font-semibold">直接データ入力</h2>
      <button
        onClick={() => setShowDirectInput(!showDirectInput)}
        className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 flex items-center gap-2"
      >
        <Edit3 className="w-4 h-4" />
        {showDirectInput ? '入力を閉じる' : '直接入力'}
      </button>
    </div>
    
    {showDirectInput && (
      <div className="border rounded-lg p-4 bg-gray-50">
        <div className="mb-4">
          <label className="block text-sm font-medium mb-2">データセット名</label>
          <input
            type="text"
            value={datasetName}
            onChange={(e) => setDatasetName(e.target.value)}
            placeholder="例: サンプルデータ1"
            className="w-full border rounded px-3 py-2"
          />
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium mb-2">
            数値データ（カンマ、スペース、改行で区切って入力）
          </label>
          <textarea
            value={directInput}
            onChange={(e) => setDirectInput(e.target.value)}
            placeholder="例: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
            rows={6}
            className="w-full border rounded px-3 py-2 font-mono text-sm"
          />
        </div>
        
        <div className="flex justify-end gap-2">
          <button
            onClick={() => {
              setDirectInput('');
              setDatasetName('');
            }}
            className="px-4 py-2 border rounded hover:bg-gray-100"
          >
            クリア
          </button>
          <button
            onClick={addDirectInputData}
            className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-2"
            disabled={!directInput.trim() || !datasetName.trim()}
          >
            <Plus className="w-4 h-4" />
            データセット追加
          </button>
        </div>
      </div>
    )}
  </div>

  {/* データセット管理 */}
  {datasets.length > 0 && (
    <div className="mb-6">
      <h2 className="text-xl font-semibold mb-3">データセット</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {datasets.map(dataset => (
          <div key={dataset.id} className="border rounded-lg p-4">
            <div className="flex items-center justify-between mb-2">
              <span className="font-medium" style={{ color: dataset.color }}>
                {dataset.name}
              </span>
              <div className="flex gap-2">
                <button
                  onClick={() => toggleDatasetVisibility(dataset.id)}
                  className="p-1 hover:bg-gray-100 rounded"
                >
                  {dataset.visible ? <Eye className="w-4 h-4" /> : <EyeOff className="w-4 h-4" />}
                </button>
                <button
                  onClick={() => removeDataset(dataset.id)}
                  className="p-1 hover:bg-gray-100 rounded text-red-500"
                >
                  <Minus className="w-4 h-4" />
                </button>
              </div>
            </div>
            <div className="text-sm text-gray-600 mb-2">
              データ数: {dataset.data.length}
            </div>
            
            {/* シグマ設定 */}
            <div className="space-y-1">
              <div className="text-sm font-medium">シグマライン:</div>
              {[1, 2, 3].map(sigma => {
                const stats = calculateStats(dataset.data);
                const upperValue = stats.mean + sigma * stats.stdDev;
                const lowerValue = stats.mean - sigma * stats.stdDev;
                return (
                  <label key={sigma} className="flex items-center space-x-2">
                    <input
                      type="checkbox"
                      checked={sigmaSettings[dataset.id]?.[`show${sigma}`] || false}
                      onChange={() => toggleSigma(dataset.id, sigma)}
                      className="rounded"
                    />
                    <span className="text-sm">
                      {sigma}σ ({lowerValue.toFixed(2)} ～ {upperValue.toFixed(2)})
                    </span>
                  </label>
                );
              })}
              <div className="text-xs text-gray-500 mt-1">
                平均: {calculateStats(dataset.data).mean.toFixed(2)}, 
                標準偏差: {calculateStats(dataset.data).stdDev.toFixed(2)}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  )}

  {/* 閾値設定 */}
  <div className="mb-6">
    <h2 className="text-xl font-semibold mb-3">閾値設定</h2>
    <div className="flex gap-2 mb-3">
      <input
        type="number"
        value={newThreshold}
        onChange={(e) => setNewThreshold(e.target.value)}
        placeholder="閾値を入力"
        className="border rounded px-3 py-2 flex-1"
      />
      <button
        onClick={addThreshold}
        className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 flex items-center gap-2"
      >
        <Plus className="w-4 h-4" />
        追加
      </button>
    </div>
    
    {thresholds.length > 0 && (
      <div className="flex flex-wrap gap-2">
        {thresholds.map(threshold => (
          <div key={threshold.id} className="flex items-center gap-2 bg-gray-100 px-3 py-1 rounded">
            <span>{threshold.value}</span>
            <button
              onClick={() => removeThreshold(threshold.id)}
              className="text-red-500 hover:text-red-700"
            >
              <Minus className="w-4 h-4" />
            </button>
          </div>
        ))}
      </div>
    )}
  </div>

  {/* 表示範囲設定 */}
  <div className="mb-6">
    <h2 className="text-xl font-semibold mb-3">表示範囲設定</h2>
    <div className="space-y-4">
      <div className="flex flex-wrap gap-4">
        <label className="flex items-center space-x-2">
          <input
            type="radio"
            value="auto"
            checked={rangeMode === 'auto'}
            onChange={(e) => setRangeMode(e.target.value)}
            className="rounded"
          />
          <span>自動（データの最小値〜最大値）</span>
        </label>
        <label className="flex items-center space-x-2">
          <input
            type="radio"
            value="6sigma"
            checked={rangeMode === '6sigma'}
            onChange={(e) => setRangeMode(e.target.value)}
            className="rounded"
          />
          <span>6シグマ範囲（平均±6σ）</span>
        </label>
        <label className="flex items-center space-x-2">
          <input
            type="radio"
            value="custom"
            checked={rangeMode === 'custom'}
            onChange={(e) => setRangeMode(e.target.value)}
            className="rounded"
          />
          <span>カスタム範囲</span>
        </label>
      </div>
      
      {rangeMode === 'custom' && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-gray-50 rounded-lg">
          <div>
            <label className="block text-sm font-medium mb-2">最小値</label>
            <input
              type="number"
              value={customMin}
              onChange={(e) => setCustomMin(e.target.value)}
              placeholder="例: 0"
              className="w-full border rounded px-3 py-2"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">最大値</label>
            <input
              type="number"
              value={customMax}
              onChange={(e) => setCustomMax(e.target.value)}
              placeholder="例: 100"
              className="w-full border rounded px-3 py-2"
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">ビン幅（オプション）</label>
            <input
              type="number"
              value={customBinWidth}
              onChange={(e) => setCustomBinWidth(e.target.value)}
              placeholder="例: 1.0"
              step="0.1"
              className="w-full border rounded px-3 py-2"
            />
            <div className="text-xs text-gray-500 mt-1">
              未入力の場合はビン数で自動計算
            </div>
          </div>
        </div>
      )}
    </div>
  </div>

  {/* ビン数設定 */}
  {rangeMode !== 'custom' || !customBinWidth ? (
    <div className="mb-6">
      <label className="block text-sm font-medium mb-2">
        ビン数: {binCount}
      </label>
      <input
        type="range"
        min="5"
        max="100"
        value={binCount}
        onChange={(e) => setBinCount(parseInt(e.target.value))}
        className="w-full"
      />
    </div>
  ) : null}
  <div className="mb-6">
    <label className="block text-sm font-medium mb-2">
      ヒストグラムの透明度: {Math.round(opacity * 100)}%
    </label>
    <input
      type="range"
      min="0.1"
      max="1"
      step="0.1"
      value={opacity}
      onChange={(e) => setOpacity(parseFloat(e.target.value))}
      className="w-full"
    />
  </div>

  {/* ビン数設定 */}
  <div className="mb-6">
    <label className="block text-sm font-medium mb-2">
      ビン数: {binCount}
    </label>
    <input
      type="range"
      min="5"
      max="50"
      value={binCount}
      onChange={(e) => setBinCount(parseInt(e.target.value))}
      className="w-full"
    />
  </div>

  {/* ヒストグラム */}
  {histogramData.data.length > 0 && (
    <div className="mb-6">
      <h2 className="text-xl font-semibold mb-3">重ね合わせヒストグラム</h2>
      <div className="h-96 w-full">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={histogramData.data} margin={{ top: 20, right: 50, left: 50, bottom: 20 }}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis 
              dataKey="x" 
              type="number"
              scale="linear"
              domain={[histogramData.range.min, histogramData.range.max]}
              ticks={getTickValues(histogramData.range.min, histogramData.range.max)}
              tickFormatter={(value) => {
                if (Number.isInteger(value)) {
                  return value.toString();
                }
                // 小数の桁数を動的に調整
                const absValue = Math.abs(value);
                if (absValue >= 1000) return value.toFixed(0);
                if (absValue >= 100) return value.toFixed(1);
                if (absValue >= 1) return value.toFixed(2);
                return value.toFixed(3);
              }}
              interval={0}
            />
            <YAxis label={{ value: '出現回数', angle: -90, position: 'insideLeft' }} />
            <Tooltip 
              labelFormatter={(value) => `値: ${value.toFixed(3)}`}
              formatter={(value, name) => [`回数: ${value}`, name]}
            />
            <Legend />
            
            {datasets.filter(d => d.visible).map((dataset, index) => (
              <Bar
                key={dataset.id}
                dataKey={dataset.name}
                fill={dataset.color}
                fillOpacity={opacity}
                stroke={dataset.color}
                strokeWidth={1}
              />
            ))}
            
            {/* 閾値線 */}
            {thresholds.map(threshold => (
              <ReferenceLine 
                key={threshold.id}
                x={threshold.value}
                stroke="red"
                strokeWidth={3}
                label={{ value: threshold.label, position: 'top' }}
              />
            ))}
            
            {/* シグマライン */}
            {getSigmaLines()}
          </BarChart>
        </ResponsiveContainer>
      </div>
      
      <div className="mt-2 text-sm text-gray-600">
        <strong>表示範囲:</strong> 
        {rangeMode === '6sigma' && ' 全データの平均から±6σの範囲'}
        {rangeMode === 'auto' && ' データの最小値から最大値まで'}
        {rangeMode === 'custom' && ` カスタム範囲 (${histogramData.range.min.toFixed(2)} ～ ${histogramData.range.max.toFixed(2)})`}
        で実際の出現回数を表示しています
        {customBinWidth && rangeMode === 'custom' && ` | ビン幅: ${customBinWidth}`}
      </div>
    </div>
  )}

  {datasets.length === 0 && (
    <div className="text-center py-12 text-gray-500">
      <div className="mb-4">
        <Upload className="w-16 h-16 mx-auto text-gray-300 mb-4" />
        <Edit3 className="w-16 h-16 mx-auto text-gray-300" />
      </div>
      <p>Excelファイルをアップロードするか、直接データを入力してヒストグラムを生成してください</p>
    </div>
  )}
</div>
```

);
};

export default HistogramTool;
